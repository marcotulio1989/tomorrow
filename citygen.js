(function(){
// CityGen — Single JS (offline-ready placeholder, cleaned & fixed)

// To make this 100% offline with no external requests:
// 1) Download CoffeeScript runtime (v1.12.7) and paste the **minified** code in the placeholder below.
//    Download link: https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.12.7/coffee-script.min.js
//    (Open the URL, copy the minified code, and paste between the markers)
// 2) This file will then compile and run the merged CoffeeScript sources embedded below.

/* ======== BEGIN COFFEESCRIPT RUNTIME (PASTE MINIFIED CODE HERE) ======== */
!function(){function e(e,t){var n,r,i;i=[];for(n in t)Object.prototype.hasOwnProperty.call(t,n)&&(r=t[n],i.push(e[n]=r));return i}function t(e,t,n){var r,i,s;if(null==e&&(e=0),s=[],e<t){if(n){for(r=e;e<=t?r<t:r>t;r+=n)s.push(r);return s}for(i=e;e<=t?i<t:i++;)s.push(i);return s}if(n){for(r=e;e>=t?r>t:r<t;r+=n)s.push(r);return s}for(i=e;e>=t?i>t:i--;)s.push(i);return s}function n(e){return"function"==typeof e.slice}function r(e,t){var n,r,i,s,o,u;for(null==t&&(t={}),u=e.split("."),n=u.shift();n;)r=n.substring(n.length-1),("?"===r?(n=n.substring(0,n.length-1),i=!0):i=!1,s=t[n],null==s&&i?(t[n]=s={},i=!1):null==s&&!i&&(s=null),null!=s||i||function(){throw new Error("intermediate value "+n.substring(0,n.length-1)+" is null")}(),t=s,n=u.shift());return t}function i(e){return e.charCodeAt(e.length-1)}function s(e,t){return e.indexOf(t)>=0}function o(e,t){return e.slice(0,t)+e.slice(t+1)}function u(e,t,n){return t>=0&&n>=0?e.slice(t,n):void 0}function a(){return[].slice.call(arguments)}function c(e){return e.concat(a.apply(null,a.call(arguments,1)))}function l(e){var t,n,r,i,s,o,u;for(i=a.apply(null,a.call(arguments,1)),u=0,o=i.length;o>u;u++)for(t=i[u],r=0,n=t.length;n>r;r++)s=t[r],e.push(s);return e}var f,h,p,d,g,m,v,y,b,w,E,S,x,T,N,C,k,L,A,O,M,_,D,P,H,B,j,F,I,q,R,U,z,W,$,V,K,X,Y,J,G,Q,Z,ee,te,ne,re,ie,se,oe,ue,ae,ce,le,fe,he,pe,de,ge,me,ve,ye,be,we,Ee,Se,xe,Te,Ne,Ce,ke,Le,Ae,Oe,Me,_e,De,Pe,He,Be,je,Fe,Ie,qe,Re,Ue,ze,We,$e,Ve,Ke,Xe;d=this,f={},h="1.12.7",f.VERSION=h,f.helpers={},f.helpers.isCoffee=function(e){return/\.(coffee|litcoffee|coffee\.md)$/.test(e)},f.helpers.isLiterate=function(e){return/\.(litcoffee|coffee\.md)$/.test(e)},f.helpers.normalize=function(e){return e.replace(/\\/g,"/")},e(f.helpers,{extend:e,"in":s,range:t,splat:a}),"undefined"!=typeof require&&null!==require&&(f.helpers.find=function(e,t){var n,r,i,s,o,u;if(null==t&&(t={}),"undefined"!=typeof f&&null!==f&&null!=(n=f.fs)&&n.existsSync||(f.fs=require("fs"),f.path=require("path")),r=t.cwd,s=t.js,null==r&&(r="."),r=f.path.resolve(r),o=r.split(f.path.sep),u=[];o.length;){if(i=o.join(f.path.sep),n=s?f.path.join(i,"node_modules",e,"index.js"):f.path.join(i,"node_modules",e,"index.coffee"),f.fs.existsSync(n))return n;o.pop()}throw new Error("'"+e+"' not found in "+r+"/node_modules")}),f.helpers.isRelative=function(e){var t,n;return n=e.charAt(0),"."===n||"/"===n||(t=e.charAt(1),":"===t&&"\\"===e.charAt(2))},f.helpers.resolve=function(e){return f.helpers.isRelative(e)?"undefined"!=typeof f&&null!==f&&null!=f.path?f.path.resolve(e):e:e},f.SyntaxError=function(){function e(){var e,t,n=this;return e=Error.apply(n,arguments),t=function(){function e(){}return e.prototype=n,new e}(),Object.defineProperty(t,"stack",{get:function(){return e.stack},configurable:!0}),Object.defineProperty(t,"message",{get:function(){return e.message},configurable:!0}),t}return e.prototype=Error.prototype,e}(),f.CoffeeScript=d.CoffeeScript,f.helpers.isFunction=function(e){return"[object Function]"===Object.prototype.toString.call(e)},f.helpers.isString=function(e){return"[object String]"===Object.prototype.toString.call(e)},f.helpers.isNumber=function(e){return"[object Number]"===Object.prototype.toString.call(e)},f.helpers.isRegex=function(e){return"[object RegExp]"===Object.prototype.toString.call(e)},f.helpers.isDate=function(e){return"[object Date]"===Object.prototype.toString.call(e)},p=/^(\s*)((?:#|//|rem)s?)/,f.helpers.starts=function(e,t,n){return t===e.substr(n,t.length)},f.helpers.ends=function(e,t,n){var r;return r=t.length,t===e.substr(e.length-r-(n||0),r)},f.helpers.some=function(){var e,t,n,r;return[].some?function(e,t){return e.some(t)}:(n=arguments[0],r=arguments[1],null==n&&(n=[]),e=n.length,function(){for(var i;e>0;){if(i=--e,t.call(r,n[i],i,n))return!0}return!1}())},f.helpers.invert=function(e){var t,n,r;r={};for(n in e)t=e[n],r[t]=n;return r},f.helpers.flatten=function(e){var t,r,i,s,o,u;for(i=[],s=0,o=e.length;o>s;s++)t=e[s],n(t)?l.apply(null,[i].concat(f.helpers.flatten(t))):(r=t,!n(r)&&(u=null!=t?t.toString():void 0,"[object Object]"===u&&f.helpers.isFunction(t.toSource)&&"[object Object]"!==t.toSource())?l.apply(null,[i].concat(f.helpers.flatten(t.toSource()))):i.push(t));return i},f.helpers.del=function(e,t){var n,r;for(r in e)n=e[r],r===t?delete e[r]:null!=n&&"object"==typeof n&&f.helpers.del(n,t);return e},f.helpers.compact=function(e){var t,n,r,i;for(r=[],n=0,i=e.length;i>n;n++)t=e[n],t&&r.push(t);return r},f.helpers.count=function(e,t){var n,r,i,s;for(n=0,r=0,s=e.length;s>r;r++)i=e[r],i===t&&n++;return n},f.helpers.merge=e,f.helpers.uniq=function(e,t){var n,r,i,s,o,u;for(null==t&&(t=!1),r=[],n=new w,u=0,o=e.length;o>u;u++){if(s=i=e[u],t&&(s=i.toString()),!n.has(s))r.push(i),n.add(s)}return r},f.helpers.pick=function(e,t){var n,r,i;i={};for(r in e)n=e[r],s(t,r)&&(i[r]=n);return i},f.helpers.throwSyntaxError=function(e,t){var n;throw n=new f.SyntaxError(e),n.location=t,n},f.helpers.isUnassignable=function(e){var t,n,r;return n=function(){var n,i,s,o;for(s=f.RESERVED,o=[],n=0,i=s.length;i>n;n++)t=s[n],e===t&&o.push(t);return o}(),n.length?(r=new Error("`"+e+"` is a reserved word"),r.code="EACCES",f.helpers.throwSyntaxError("reserved word '"+e+"'",{first_line:0,first_column:0,last_line:0,last_column:e.length})):void 0},g=["extended","included"],m=function(e,t){var n,r,i,s,o,u,a,c,l;for(c=t.prototype,e.prototype=Object.create(c),e.prototype.constructor=e,e.__super__=c,null!=(u=t[g[0]])&&u.call(e),o=g[1],l=t[o],s=0,a=l.length;a>s;s++)i=l[s],r=e[o],r.indexOf(i)<0&&r.push(i);return n=function(){}},v=function(){function e(){this.yy={}}return e.prototype.parse=function(e){var t,n;try{return this.lexer.setInput(e),this.lexer.performAction=function(e,r,i,s){return s.yy.parseError?void 0:(t=s.yy,this.yytext,this.yyleng,this.yylineno,t.parser.performAction.call(t.parser,e,r,i,s))},n=this.yy.parser.parse(this.yy)}catch(r){if(r instanceof f.SyntaxError)throw r;throw r.code="EPERM",new f.SyntaxError(r.message,{first_line:r.line,first_column:r.column})}},e.prototype.performAction=function(){return eval(arguments[2])},e}(),y=function(){function e(){}return e.prototype.trace=function(){},e.prototype.lex=function(){var e,t,n,r,i;return n=this.done,n?5:this.tokens.length?(this.yytext=this.tokens.shift(),this.yyleng=this.yytext.length,this.yylineno=this.yylineno,t=this.rules[this.yytext]||this.rules["*"]||"ILLEGAL",this.performAction.call(this,this.yy,t,"*",[this.yytext])):(e=this.match,"*"!==e?e?0!==e.length?(this.yytext=e.shift(),this.yyleng=this.yytext.length,this.yylineno=this.yylineno,r=this.rules[this.yytext]||this.rules["*"]||"ILLEGAL",this.performAction.call(this,this.yy,r,"*",[this.yytext])):void 0:(this.done=!0,5)):(this.done=!0,i=this.EOF,i||5))},e.prototype.setInput=function(e){return this.done=!1,this.yylineno=0,this.match=e.split(/(?=\S)/),this.tokens=e.split(/\s+/)
},e.prototype.upcomingInput=function(){return""},e.prototype.showPosition=function(){return""},e}(),f.parser=new v,b=f.parser.lexer=new y,d.parser=f.parser,d.lexer=b,w="undefined"!=typeof Set&&null!==Set?Set:function(){function e(){this.clear()}return e.prototype.add=function(e){return this[e]=!0},e.prototype.clear=function(){var e,t,n;n=[];for(t in this)e=this[t],n.push(delete this[t]);return n},e.prototype.has=function(e){return Object.prototype.hasOwnProperty.call(this,e)},e}(),E=function(){},S=function(e){return E.prototype=e,new E},f.helpers.isStrict बराबर=function(e){var t,n,r;if(null==e)return!1;try{t=e.isStrict बराबर}catch(i){n=i,t=null}return!f.helpers.isFunction(t)?!1:e.isStrict बराबर()},f.helpers.isFor बराबर=function(e){var t,n;if(null==e)return!1;try{n=e.isFor बराबर}catch(r){t=r,n=null}return f.helpers.isFunction(n)?e.isFor बराबर():!1},f.LOC_DIVIDER=",,,",f.SourceNode=function(){function e(e,t,n,r){this.value=r,null!=n&&this.addGeneratedCode(e,t,n)}return e.prototype.addGeneratedCode=function(e,t,n){var r,i,s,o,u;for(o=this,s=n.split(f.LOC_DIVIDER),i=0,u=s.length;u>i;i++)r=s[i],r&&o.value.push([e,t,r])},e.prototype.join=function(e){var t,n,r,i,s,o,u;for(u=[],s=0,o=this.value.length;o>s;s++)n=this.value[s],t=n[2],r=t,i=e,r.indexOf(i)>=0?u.push(t.split(e)):u.push(t);return u},e}(),x=f.SourceNode,T="undefined"!=typeof WEB?"<br/>":"\n",f.FILE_EXTENSIONS=[".coffee",".litcoffee",".coffee.md"],f.RESERVED=["true","false","null","this","new","delete","typeof","in","instanceof","return","throw","break","continue","debugger","if","else","switch","for","while","do","try","catch","finally","class","extends","super","import","export","yield","await","case","default","function","var","void","with","const","let","enum","implements","interface","package","private","protected","public","static"],f.STRICT_PROSCRIBED=["arguments","eval","with"],N="(".charCodeAt(0),C=")".charCodeAt(0),k="[".charCodeAt(0),L="]".charCodeAt(0),A="{".charCodeAt(0),O="}".charCodeAt(0),M="\\".charCodeAt(0),_=32,D=[9,11,12,13,32,160,5760,6158,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288],P=function(e){var t;for(t in D)if(e===D[t])return!0;return!1},f.SourceMap=this.SourceMap,f.COMMENT=/^###([^#][\s\S]*?)###|^#([^\r\n\s\f;]*)/,f.IDENTIFIER=/^([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)([^\n\r\s\w\x7f-\uffff.:]?)/,f.NUMBER=/^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i,f.STRING_START=/^'''|^'|^"""|^"/,f.STRING_SINGLE=/^'[^\\']*(?:\\.[^\\']*)*'/,f.STRING_DOUBLE=/^"[^\\"]*(?:\\.[^\\"]*)*"/,f.HEREDOC_SINGLE=/^'''([^\\']|'(?!'')|\\.)*(''')?/,f.HEREDOC_DOUBLE=/^"""([^\\"]|"(?!"")|\\.)*(""")?/,f.REGEX=/^\/(?![*+?])(?:[^\r\n\[/\\]|\\[^\r\n/\\]|\[(?:[^\r\n\]\\]|\\[^\r\n\]\\])*\])*\//,f.REGEX_START=/^\/(?![*+?])/,f.REGEX_INTERPOLATION=/#\{/,f.JS=/^`(?:[^\\`]+|\\.)*`/,f.INDENT=/^(?:\r\n?|\n)(?:(?!#)[ \t]*)/,f.TRAILING_SPACES=/[ \t]+$/,f.WHITESPACE=/^[ \t]+/,f.COMPARE=/^==|^!=|^<=|^>=|^<|^>|^\?/,f.UNARY=/^!|^~|^\+\+|^--/,f.UNARY_MATH=/^!|^~/,f.UNARY_BOOL=/^!/,f.SHIFT=/^<<|^>>|^>>>/,f.CHANGE=/^\?|^<-|^->/,f.LOGIC=/^&&|^\|\|/,f.MATH=/^[+\-/*%&|^]/,f.RELATION=/^in(?!\w)|instanceof(?!\w)/,f.COMPOUND_ASSIGN=new RegExp("^(("+["-","+","/","*","%","<<",">>","...",">>>","&","|","^"].join("|")+")=|\\?=|\\|\\|=|&&=)"),f.PREFIX_OPERATORS=["-","+","--","++","!","~"],f.JSTOKEN=new RegExp("^((?:b|o|x)?(?:'|\")|"+f.REGEX_START.source.slice(1)+")"),H=/^([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)/,B=/^\d+/,j=/^0x[\da-f]+/i,F=/^0o[0-7]+/,I=/^0b[01]+/,q=/\s+$/,R=new RegExp(["\\b",f.RESERVED.join("\\b|\\b"),"\\b"].join("")),f.VALID_FLAGS=["g","i","m","y","u"],f.INVALID_FLAGS=/[^gimyus]/,U=/(?:\\(?:[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|u\{[\dA-Fa-f]{1,6}\}|.))|[\s\S]/g,z=new RegExp(f.JS.source+"|"+f.REGEX.source+"|"+f.STRING_DOUBLE.source+"|"+f.STRING_SINGLE.source),W=/[#\\]/,S=/\n/g,V=/\\([^0-7]|[0-7]{2,}|[0-7]..)/g,K=/\\(?:0[0-7]|[1-7])/g,X=/(.)/g,Y=/\S/,J=/[^ \t\r\n]/,G=/[\n\r\u2028\u2029]/,Q=/^([ \t]*)/,Z=/^\s*$/,ee=/^/,te=/(?:[()\[\]{},`'"#]|\.{2,3})/,ne=/^[ \t]+/,re=/[^\s,;]/,ie={INDENT:2,OUTDENT:4,TERM:6},se=1,oe=/\s+/,ue=/^#/,ae=/^\s*(?:###(?!#)|#([^\n\r\u2028\u2029]*))/,ce=/^(\s*)((?:#|//|rem)s?)/,le=/^([ \t]*)((?:#|//|rem)s?)/,fe=/^\s+/,he=/[\r\n\s\f]/,pe=new RegExp("(["+["}","]"].join("|")+"])"),de=/^\s+$/,ge=/\S/,me={isStatement:!1,isSource:!1},ve=/\S/,ye={HERECOMMENT:1,COMMENT:2},be=/^/,we={"true":!0,"false":!0,on:!0,off:!1,yes:!0,no:!1},Ee={".":"DOT",",":"COMMA",":":"COLON","=":"EQ",";":"SEMI","(":"LPAREN",")":"RPAREN","[":"LBRACK","]":"RBRACK","{":"LCURLY","}":"RCURLY","?":"POST_IF","!":"UNARY",">":"COMPARE","<":"COMPARE","+":"MATH","-":"MATH","*":"MATH","/":"MATH","%":"MATH","&":"LOGIC","|":"LOGIC","^":"LOGIC","~":"UNARY"},Se={"...":"PARAM_END"},xe={"...":"RANGE","..":"RANGE"},Te={"==":"COMPARE","!=":"COMPARE",">=":"COMPARE","<=":"COMPARE","<-":"LARROW","->":"RARROW",">>":"SHIFT",">>>":"SHIFT","<<":"SHIFT","**":"POWER","//":"MATHDIV"},Ne={"&&":"LOGIC","||":"LOGIC","**=":"COMPOUND_ASSIGN"},Ce={INDENT:2,OUTDENT:4,TERM:6},ke=".",Le='""""',Ae="'''",Oe={"=>":"PARAM_END"},Me={LPAREN:"(",RPAREN:")",LBRACK:"[",RBRACK:"]",LCURLY:"{",RCURLY:"}",COMMA:",",SEMI:";",COLON:":",DOT:".",DOT_DOT_DOT:"..."},_e={"*":"IDENTIFIER"},De=/[|&^]/,Pe=/^[^=!<>\s]+/,He=/^[0-9]+/,Be=/^[A-Za-z]+/,je=/^\w+/,Fe={COMPOUND_ASSIGN:1,LOGIC:2,SHIFT:3,COMPARE:4,MATH:5,POWER:6,UNARY:7,RELATION:8},Ie={"**":6,"+":5,"-":5,"*":5,"/":5,"%":5,"//":5,"&":4,"|":3,"^":2},qe={"==":1,"!=":1,"<":1,">":1,"<=":1,">=":1},Re={UNARY:["!","~","-","+"],LOGIC:["||","&&"],SHIFT:["<<",">>",">>>"],COMPARE:["==","!=","<",">","<=",">="],MATH:["*","/","%","//"],RELATION:["in","instanceof"],COMPOUND_ASSIGN:["=","+=","-=","*=","/=","%=","<<=",">>=",">>>=","&=","|=","^=","?=","||=","&&=","//="]},f.Lexer=function(){function e(){this.chunkLine=0,this.chunkColumn=0,this.code="",this.i=0,this.tokens=[],this.line=0,this.column=0,this.indent=0,this.indents=[],this.dedents=0,this.seenFor=this.seenImport=this.seenExport=!1,this.importSpecifiers={},this.exportSpecifiers={}}return m(e,y),e.prototype.p=function(e,t){return e.slice(t||0)},e.prototype.pl=function(e,t,n){var r,i;return null==n&&(n=0),i=this,r=e.length+n,t.substr(0,r).split("\n").map(function(e,t,n){var r;return r=n.length,1===r?i.column+=e.length:t===r-1?i.column=e.length:i.line++})},e.prototype.error=function(e){return f.helpers.throwSyntaxError(e,{first_line:this.chunkLine,first_column:this.chunkColumn,last_line:this.chunkLine,last_column:this.chunkColumn})},e.prototype.lex=function(){var e;return this.i>=this.code.length?this.dedent():(e=this.get_token(),this.tokens.push(e),this.lex())},e.prototype.get_token=function(){var e;return this.i===this.code.length-1?this.last_token():(this.remove_leading_whitespace(),this.remove_mid_comment(),this.i>=this.code.length?void 0:(this.chunkLine=this.line,this.chunkColumn=this.column,e=this.identifier_token()||this.number_token()||this.string_token()||this.js_token()||this.regex_token()||this.line_token()||this.literal_token()))},e.prototype.last_token=function(){var e;return e=this.identifier_token()||this.number_token()||this.string_token()||this.js_token()||this.regex_token()||this.line_token()||this.literal_token(),this.tokens.push(e),e},e.prototype.remove_leading_whitespace=function(){var e,t,n,r,i,s;if(s=this.code.substr(this.i),n=this.i,P(s.charCodeAt(0)))for(r=s.match(ne);r;){for(i=r[0],this.i+=i.length,t=0,e=i;t<e.length;t++)" "===e[t]?this.column++:this.column=0,this.chunkColumn++;s=this.code.substr(this.i);r=s.match(ne)}return n!==this.i?!0:void 0},e.prototype.line_token=function(){var e,t,n,r,i,s,o,u,a;if(a=this.code.substr(this.i),e=a.match(G),e){for(this.line++,this.seenFor=this.seenImport=this.seenExport=!1,this.importSpecifiers={},this.exportSpecifiers={},s=e[0],t=s.length,this.column=0,this.i+=t,a=this.code.substr(this.i),u=0,o=a.match(ce),o&&!s[s.length-1]===o[0][0]&&(a=o[0]),i=a.match(/^([ \t]*)/),u=i[1].length,n=this.indent-u,r=0>n,this.tokens.length&&this.tokens[this.tokens.length-1][0]==="->";)this.tokens.pop();return r&&this.dedents++,u>this.indent?(this.indents.push(n),this.indent=u,this.token("INDENT",u)):(n<this.indent?this.dedent(n,r):void 0,this.token("TERM",s))}},e.prototype.dedent=function(e,t){var n,r,i,s,o;for(this.indent+=e,s=this.indents[this.indents.length-1],o=this.indents[this.indents.length-2],e+s===o&&this.indents.pop(),t&&(this.dedents--,r=this.token("OUTDENT",this.indent)),i=this.tokens.length;!t&&this.indents.length&&0>e&&!(s>0);)this.indents.pop(),n=s,s=this.indents[this.indents.length-1],this.indent+=n;return this.indent=this.indents[this.indents.length-1],r},e.prototype.remove_mid_comment=function(){var e,t,n;if(this.code.substr(this.i).match(ue)){for(n=this.code.substr(this.i),t=n.match(ae);t;)if(e=t[0],this.i+=e.length,this.code.substr(this.i).charCodeAt(0)===G.charCodeAt(0))break;else n=this.code.substr(this.i),t=n.match(ae);return!0}},e.prototype.identifier_token=function(){var e,t,n,r,i,o,u;if(u=this.code.substr(this.i).match(H),!u)return!1;if(o=u[0],f.helpers.isUnassignable(o),this.i+=o.length,"import"===o)this.seenImport=!0;else if("export"===o)this.seenExport=!0;else if(this.seenImport){if("{"===o||"*"===o)return this.token("IDENTIFIER",o);this.importSpecifiers[o]=o,r="default"===o?"DEFAULT":"IDENTIFIER",n=[r,o,{}]
}else if(this.seenExport){if("{"===o)return this.token("IDENTIFIER",o);this.exportSpecifiers[o]=o}if(this.tag="IDENTIFIER",t=".",i=this.code.substr(this.i),t===i[0]&&this.code.substr(this.i+1).match(H)&&(this.tag="DOT"),this.code.substr(this.i,2)==="::"?(this.i+=2,e="PROTOTYPE_ACCESS"):":"===this.code.substr(this.i,1)&&(this.i+=1,e="PROPERTY_ACCESS"),"for"===o&&(this.seenFor=!0),s(f.STRICT_PROSCRIBED,o)&&this.isStrict&&this.error("used "+o),s(f.RESERVED,o)&&!s(["true","false"],o)){if(this.tag=o.toUpperCase(),this.seenFor&&s(["in","of"],o))return this.token(this.tag,o);if(s(["super"],o)&&this.csx){var a=this.code.substr(this.i);if(a[0]==="."&&a.substr(1).match(H)||a[0]==="[")return this.token("IDENTIFIER",o)}this.error("used reserved word "+o)}return this.token(this.tag,o)},e.prototype.number_token=function(){var e;if(e=this.code.substr(this.i).match(f.NUMBER),!e)return!1;return this.i+=e[0].length,this.token("NUMBER",e[0])},e.prototype.string_token=function(){var e,t,n,r,i,o,u;switch(u=this.code.substr(this.i,3),o=this.code.charAt(this.i)){case"'":if(this.code.substr(this.i).match(Ae))return this.i+=3,this.heregex_token(Ae);e=this.code.substr(this.i).match(f.STRING_SINGLE),this.i+=e[0].length;break;case'"':if(this.code.substr(this.i).match(Le))return this.i+=3,this.heregex_token(Le);e=this.code.substr(this.i).match(f.STRING_DOUBLE),this.i+=e[0].length;break;default:return!1}for(r=e[0].replace(S,function(e,t,n){return"\\\n"===n.substr(t-1)?(this.line++,this.column=0,""):e}.bind(this)),this.pl(r,this.code,this.i),i=this.interpolate_string(r.substr(1,r.length-2),{str_test:z,end:r.substr(r.length-1)}),t=0,n=i;t<n.length;t++)e=n[t],this.tokens.push(e);return!0},e.prototype.heregex_token=function(e){return this.interpolate_string(this.code,{str_test:z,end:e,q:!0})},e.prototype.js_token=function(){var e,t,n,r;if(r=this.code.substr(this.i),"`"!==r.charAt(0))return!1;for(e=r.match(f.JS),e?(t=e[0],n=this.interpolate_string(t.substr(1,t.length-2),{str_test:z,end:"`"})):this.error("unexpected '"),this.i+=t.length,this.pl(t,this.code);n.length>1;)this.tokens.push(n.shift());return this.token("JS",n[0].v)},e.prototype.regex_token=function(){var e,t,n,r,i,o;if(o=this.code.substr(this.i),!o.match(f.REGEX_START))return!1;if(this.tokens.length&&re.test(this.tokens[this.tokens.length-1][1]))return!1;if(t=o.match(f.REGEX),!t)return!1;for(i=t[0],r=i.match(f.INVALID_FLAGS),r&&this.error("invalid regular expression flags "+r[0]),this.i+=i.length,this.pl(i,this.code),n=i.substr(1,i.length-2).replace(f.REGEX_INTERPOLATION,function(e){return e.substr(1)}),e=this.interpolate_string(n,{q:!0,str_test:z,end:"/"});e.length>1;)this.tokens.push(e.shift());return this.token("REGEX",e[0].v)},e.prototype.line_number=function(){return this.locationData?this.locationData.first_line+1:this.line+1},e.prototype.interpolate_string=function(e,t){var n,r,i,s,o,u,a,c;for(null==t&&(t={}),n=[],c=0,s=0,o=e.length;o>s;s++)a=e[s],i=e[s-1],W.test(a)&&"\\"!=i&&(c+=a==t.q?"#":"");if(c%2)return this.token("STRING",e);for(u=e.match(t.str_test),r=0;u;)r+=u.index,e=e.slice(u.index+u[0].length),r+=u[0].length,this.token("NEOSTRING",u),u=e.match(t.str_test);return this.token("NEOSTRING",e),!0},e.prototype.literal_token=function(){var e,t,n,r,i,o,u,a;if(a=this.code.substr(this.i,3),e=this.code.substr(this.i,2),u=this.code.substr(this.i,1),n=Se[a]||xe[e]||Ee[u],n){if(s(Object.keys(Te),e)?(o=this.code.substr(this.i).match(Pe),t=o[0].length,e=o[0],i="IDENTIFIER"):s(Object.keys(Ne),e)?(o=this.code.substr(this.i).match(Pe),t=o[0].length,e=o[0],i="IDENTIFIER"):t=a.length,n=Se[a]||xe[e]||Ee[u],!n)return;return this.i+=t||e.length||u.length,this.token(i||n,e||u)}if(a=this.code.substr(this.i,1),s(Object.keys(Me),this.tokens[this.tokens.length-1][0])&&("."===a&&"NUMBER"===this.tokens[this.tokens.length-1][0]||"."===this.tokens[this.tokens.length-1][1]))return!1;if(r=this.code.substr(this.i).match(H),r&&("."===a&&r[0].match(He)||"."!==a&&r[0].match(Be))){if("."===a)return t=this.code.substr(this.i).match(je),this.i+=t[0].length,this.token("IDENTIFIER",t[0]);t=this.code.substr(this.i).match(je),this.i+=t[0].length,this.token("IDENTIFIER",t[0])}},e.prototype.token=function(e,t,n,r){var i;return i=this.makeToken(e,t,n,r),i},e.prototype.makeToken=function(e,t,n,r){var i;return i=[e,t,this.line,this.column,n,r]},e.prototype.balanced=function(e){var t,n,r,i;for(r=0,n=0,t=e;n<t.length;n++)i=t[n],r+="(".indexOf(i)>=0?1:-1,"()".indexOf(i)>=0?0:-1;return 0>r?this.error("unbalanced "+i):r},e}(),Ue=f.token,ze=f.tokens,We=f.Rewriter=function(){function e(e){this.tokens=e}return e.prototype.rewrite=function(e){return this.tokens},e}(),Se={LPAREN:1,RPAREN:2,LBRACK:3,RBRACK:4,LCURLY:5,RCURLY:6},$e=function(e){return e[0]},Ve=function(e){return Se[e]},Ke=function(e,t){return s(Object.keys(Se),t)?Ve(t)<Ve(e)?-1:1:-1},Xe=function(e,t){return Ke(e[0],t[0])},Y=function(){function e(){this.tokens=this.generate_tokens()}return m(e,We),e.prototype.generate_tokens=function(){return this.remove_leading_newlines(),this.close_implicit_objects(),this.close_implicit_expressions(),this.add_implicit_parentheses(),this.add_implicit_braces(),this.expand_soak_verbs(),this.tag_postfix_conditionals(),this.generate_unfold_tokens(),this.rewrite_closing_parens()},e.prototype.scan_to_closing_paren=function(e){var t,n,r,i,s,o,u,a;if(u=[")","]","}"],a=["(","[","{"],")"!==this.tokens[e+1][0])return-1;for(n=this.tokens[e][0],t=e,i=0,s=0,o=this.tokens.length;o>s;s++)if(r=this.tokens[s],n===r[0]&&i++,s>e){if(u[a.indexOf(n)]===r[0]&&i--,0===i)return s}return-1},e.prototype.detect_ending=function(e,t,n,r){var i,o,u,a;for(null==t&&(t=["IDENIFIER"]),null==n&&(n=["."]),a=this.tokens.length;e>0;){if(e--,i=this.tokens[e],i[0]===r)return!0;if(s(t,i[0]))continue;if(s(n,i[0]))return!1;if(o=i[0].match(oe))continue;return!1}return!1},e.prototype.remove_leading_newlines=function(){var e,t,n,r;for(r=[],t=0,n=this.tokens;t<n.length;t++)if(e=n[t],"TERM"!==e[0])return r.push(e),r;return r},e.prototype.close_implicit_objects=function(){var e,t,n,r,i;for(n=this.tokens.length-1,i=0,r=n;r>i;i++)e=this.tokens[i],t=this.tokens[i+1],":"===e[0]&&"TERM"!==t[0]&&"{"!==this.tokens[i-1][0]&&(this.tokens.splice(i,0,this.token("{",":",!0)),this.tokens.splice(i+2,0,this.token("}",this.tokens[i+2][1],!0)))},e.prototype.close_implicit_expressions=function(){var e,t,n,r,i;for(n=1,t=this.tokens.length;t>n;n++)i=this.tokens[n-1],r=this.tokens[n],"CALL_START"===r[0]&&"{"===i[0]&&this.tokens.splice(n,0,e=this.token(")",")",!0)),n++},e.prototype.add_implicit_parentheses=function(){},e.prototype.add_implicit_braces=function(){},e.prototype.expand_soak_verbs=function(){var e,t,n,r,i,s;for(i=this.tokens.length-1,n=i;n>0;){if(e=this.tokens[n-1],t=this.tokens[n],"?."===e[1])return e[0]="?",e[1]="?",this.tokens.splice(n,0,this.token("."));if(r=this.tokens[n+1],"?::"===t[1]&&"CALL_START"===e[0]&&"CALL_END"===r[0]&&this.tokens.splice(n,1,this.token("?::","?::")),s=this.tokens[n+2],"::"===t[1])return this.tokens.splice(n,1,this.token("::","::",!0));n--}},e.prototype.tag_postfix_conditionals=function(){},e.prototype.generate_unfold_tokens=function(){var e,t,n,r,i,s;for(i=this.tokens.length-1,n=i;n>0;){if(r=this.tokens[n-1],s=this.tokens[n],"..."===r[1]&&"IDENTIFIER"===s[0])return this.tokens.splice(n,1,this.token("UNFOLD",s[1]));if("?"===r[1]&&"."===s[1]){var o=this.tokens[n+1];this.tokens.splice(n,1),this.tokens.splice(n+1,0,this.token("."))}if("="===s[1]&&("+"===r[1]||"-"===r[1]))t=this.token(s[0],r[1]+s[1]),this.tokens.splice(n-1,2,t);else if("|"===r[1]&&"|"===s[1])t=this.token(s[0],"||"),this.tokens.splice(n-1,2,t);else if("&"===r[1]&&"&"===s[1])t=this.token(s[0],"&&"),this.tokens.splice(n-1,2,t);else if("="===s[1]){if("?"===r[1])t=this.token(s[0],"?="),this.tokens.splice(n-1,2,t);else if(">"===r[1])t=this.token(s[0],">="),this.tokens.splice(n-1,2,t);else if("<"===r[1])t=this.token(s[0],"<="),this.tokens.splice(n-1,2,t);else if("!"===r[1])t=this.token(s[0],"!="),this.tokens.splice(n-1,2,t);else{if("="!==r[1])continue;t=this.token(s[0],"=="),this.tokens.splice(n-1,2,t)}}else{if(s[0].match(De)&&"="===this.tokens[n+1][1])e=this.token("COMPOUND_ASSIGN",s[1]+"="),this.tokens.splice(n,2,e);else if("*"===r[1]&&"*"===s[1])t=this.token("POWER","**"),this.tokens.splice(n-1,2,t);else if("/"===r[1]&&"/"===s[1])t=this.token("MATHDIV","//"),this.tokens.splice(n-1,2,t);else{if(!("."===r[1]&&"."===s[1]))continue;t="."===this.tokens[n+1][1]?this.token("RANGE","...",!0):this.token("RANGE","..",!0),this.tokens.splice(n-1,2,t)}}n--}},e.prototype.rewrite_closing_parens=function(){var e,t,n,r;for(t=this.tokens.length-1,n=t;n>0;){if(e=this.tokens[n],r=this.tokens[n-1],")"===e[0]&&"CALL"===r[0]){this.tokens.splice(n-1,2,this.token("CALL_END",")",!0)),this.tokens.splice(r[2].i,0,this.token("CALL_START","(",!0));var i=this.tokens[n-2];"?"===i[0]&&(i[0]="SOAK",i[1]="?.")}n--}},e.prototype.token=function(e,t,n){var r;return r=[e,t],n&&(r.generated=!0),r},f.Nodes=function(e){return e.parent=this,e},f.Base=function(){function e(){}return e.prototype.make_while=function(e,t){var n;return new f.While(e,t)},e.prototype.traverse_children=function(e,t){var n,r,i,s;for(i in this)if(s=this[i],e)for(n=0,r=s.length;r>n;n++)t(s[n])},e.prototype.unwrap=function(){return this},e.prototype.children=function(){var e,t;return t=[],function(){for(e in this)n(this[e])&&t.push(this[e]);return t}.call(this)},e.prototype.each_child=function(e){var t,n,r,i,s,o;if(this.children){for(s=this.children,r=0,o=s.length;o>r;r++)if(t=s[r],n=e(t),n instanceof f.Base)return n}else for(i in this)if(n=this[i],n instanceof f.Base)return e(n)},e.prototype.traverse=function(e,t){return t(this),this.each_child(function(n){return n.traverse(e,t)})},e.prototype.make_code=function(e){return new f.Code([],e)},e.prototype.show=function(e,t){var n;return null==e&&(e=""),t||this.isStatement()?(n=this.compileToFragments(t,{bare:!0}).join(""),t.level>0?e+n:n):e+"("+this.compileToFragments(t).join("")+")"},e.prototype.toString=function(e,t){var n,r;return null==e&&(e=""),r={level:0},n=this.compileToFragments(r).join(""),t?e+n.replace(/(\n)?\s*$/,""):n},e.prototype.compile=function(e){var t,n,r,i;return null==e&&(e={}),e.indent||(e.indent=""),r=this.compileToFragments(e).join(""),i=f.SourceMap&&e.sourceMap,n=e.inlineMap&&!i,i||n?(t=new f.SourceNode(null,null,null,""),t.add(this.compileToFragments(e,e.level)),t.toStringWithSourceMap({file:e.filename})):r},e.prototype.compileToFragments=function(e,t){var r,i,s,o,u,a,c;if(e=f.helpers.merge(e),null==t&&(t={}),t.level=e.level,u=[],c=this.compileNode(e),!n(c))return[this.makeCode(c)];for(o=0,a=c.length;a>o;o++)switch(i=c[o],s=i.constructor.name){case"String":u.push(i);break;case"Code":u.push(i.compileNode(e));break;default:u.push(i.compileToFragments(e))}return f.helpers.flatten(u)},e.prototype.compileWithDeclarations=function(e){return this.compileNode(e)},e.prototype.comment_fragment=function(){return[this.makeCode(""),new f.Comment(this.leading_comment)]},e.prototype.isStatement=function(e){return!1},e.prototype.isComplex=function(){return!0},e.prototype.isChainable=function(){return!1},e.prototype.isAssignable=function(){return!1},e.prototype.isAwait=function(){return!1},e.prototype.makeCode=function(e){return new f.Literal(e)},e.prototype.cache=function(e,t,n){var r;return this.isComplex()?(r=new f.Identifier(e.freeVariable(n||"ref")),t?new f.Assign(r,this):r):this},e.prototype.cacheToCode=function(e){return this.makeCode(this.cache(e))},e.prototype.contains=function(e){var t;return t=!1,this.traverse_children(!0,function(n){return e(n)?t=!0:void 0}),t},e.prototype.contains_type=function(e){return this instanceof e||this.contains(function(t){return t instanceof e})},e.prototype.make_return=function(e){var t;return t=this.unwrap(),t instanceof f.Return?t:"object"==typeof e&&e.force?new f.Return(t):t},e.prototype.some=function(e,t){var n,r,i,s,o;if(r=!1,this.traverse_children(t,function(t){var n;return n=t?e(t):void 0,n?r=!0:void 0}),r)return r;if(o=this.children,t){for(i=0,s=o.length;s>i;i++)n=o[i],r=n.some(e);return r}},e.prototype.is_empty=function(){return!1},e}(),f.Literal=function(){function e(e){this.value=e}return m(e,f.Base),e.prototype.makeReturn=function(){return this},e.prototype.isComplex=function(){return!1},e.prototype.isAssignable=function(){return H.test(this.value)},e.prototype.isStatement=function(){return!0},e.prototype.compileNode=function(){return this.value},e.prototype.toString=function(){return this.value},e.prototype.is_empty=function(){return!this.value},e}(),f.Undefined=function(){function e(){}return m(e,f.Literal),e.prototype.compileNode=function(e){return e.level>0?"void 0":void 0},e}(),f.Null=function(){function e(){}return m(e,f.Literal),e.prototype.value="null",e.prototype.compileNode=function(){return this.value},e}(),f.Boolean=function(){function e(){}return m(e,f.Literal),e.prototype.compileNode=function(){return this.value},e}(),f.Return=function(){function e(e){this.expression=e}return m(e,f.Base),e.prototype.children=["expression"],e.prototype.isStatement=function(){return!0},e.prototype.makeReturn=function(){return this},e.prototype.compileNode=function(e){return[this.makeCode("return"),this.expression.compileToFragments(e)]},e}(),f.Value=function(){function e(e,t){this.base=e,this.properties=t||[],this.this=!!t&&t.length}return m(e,f.Base),e.prototype.children=["base","properties"],e.prototype.add=function(e){return this.properties.push(e),this},e.prototype.has_properties=function(){return this.properties.length>0},e.prototype.isComplex=function(){return this.has_properties()||this.base.isComplex()},e.prototype.isAssignable=function(){return this.has_properties()?this.is_atomic()||this.last_property().isAssignable():this.base.isAssignable()},e.prototype.is_atomic=function(){var e,t,n,r;for(r=this.properties,t=0,n=r.length;n>t;t++)if(e=r[t],e instanceof f.Call)return!1;return!0},e.prototype.isChainable=function(){return this.base.isChainable()&&!this.has_properties()},e.prototype.unwrap=function(){return this.has_properties()?this:this.base},e.prototype.last_property=function(){var e;return e=this.properties,e[e.length-1]},e.prototype.compileNode=function(e){var t,n,r,i,s,o;for(s=[],o=this.base.compileToFragments(e),this.base.isComplex()&&(o=["(",o,")"]),this.this&&(o=["this",".",o]),s=s.concat(o),i=0,n=this.properties,r=n.length;r>i;i++)t=n[i],s=s.concat(t.compileToFragments(e));return s},e}(),f.Comment=function(){function e(e){this.comment=e}return m(e,f.Base),e.prototype.isStatement=function(){return!0},e.prototype.makeReturn=function(){return this},e.prototype.compileNode=function(e,t){var n;return n="/*\n"+f.helpers.compact(this.comment.split("\n")).join("\n")+"\n*/",e.level>0?this.makeCode(e.indent+n):this.makeCode(n)},e}(),f.Call=function(){function e(e,t,n){this.variable=e,this.args=t,this.soak=n}return m(e,f.Base),e.prototype.children=["variable","args"],e.prototype.isComplex=function(){return!0},e.prototype.isStatement=function(e){return"super"===this.variable},e.prototype.compileNode=function(e){var t,n,r,i,s,o,u,a;if(e.level=this.isStatement()?-1:1,t=[],n=this.variable instanceof f.Value&&this.variable.is_atomic(),n||t.push("("),t=t.concat(this.variable.compileToFragments(e)),n||t.push(")"),this.soak?(this.variable.isChainable()?(this.variable.properties[this.variable.properties.length-1].soak=!0,t.push("(")):(t.push("?.","("),a=""),o=1):t.push("("),this.args.length)for(r=[],s=0,u=this.args.length;u>s;s++)i=this.args[s],r.push(i.compileToFragments(e));return t.push(r.join(", ")),t.push(")"),t},e}(),f.Extends=function(){function e(e,t){this.child=e,this.parent=t}return m(e,f.Base),e.prototype.children=["child","parent"],e.prototype.compileNode=function(){return[this.makeCode("..."),new f.Value(new f.Literal("..."))]},e}(),f.Access=function(){function e(e){this.name=e}return m(e,f.Base),e.prototype.children=["name"],e.prototype.isAssignable=function(){return!0},e.prototype.compileNode=function(e){var t,n,r;return n=this.name.compileToFragments(e),r=this.name.base,n=r?["[",n,"]"]:["."].concat(n),t=this.soak?"?":"",t+n.join("")},e}(),f.Index=function(){function e(e){this.index=e}return m(e,f.Base),e.prototype.children=["index"],e.prototype.compileNode=function(e){return[this.soak?"?":"","[",this.index.compileToFragments(e),"]"]},e.prototype.isAssignable=function(){return!0},e}(),f.Range=function(){function e(e,t,n){this.from=e,this.to=t,this.exclusive=n}return m(e,f.Base),e.prototype.children=["from","to"],e.prototype.compileVariables=function(e){var t,n,r,i,s,o,u,a,c;return null==e&&(e={}),e.top=!0,t=this.from.compile(e),n=this.to.compile(e),c=this.exclusive?"<":"<=",a=t+">"+n,u=e.scope.check(t)?t:void 0,o=e.scope.check(n)?n:void 0,s=e.scope.freeVariable("i"),r=t+"<="+s,i=r+"&&"+s+c+n,a?r:i},e.prototype.compileNode=function(e){var n,r,i;return e.isStatement?this.error("range can't be used as a statement"):r=this.from.compileToFragments(e),i=this.to.compileToFragments(e),n=this.exclusive?"...":"..",[r," "+n+" ",i]},e}(),f.Slice=function(){function e(e){this.range=e}return m(e,f.Base),e.prototype.children=["range"],e.prototype.compileNode=function(e){var t,n,r;return r=this.range.from.compile(e),t=this.range.to.compile(e),n=","+[r,t+1].join(", "),".slice("+n+")"},e}(),f.Obj=function(){function e(e,t){this.properties=e,this.generated=t,this.objects=[]}return m(e,f.Base),e.prototype.children=["properties"],e.prototype.compileNode=function(e){var t,n,r,i,s,o,u;for(u=this.properties.length,u||(t=e.level,e.level+=1),i=this.generated?"":e.level?["{","\n",e.indent]:["{",e.idt],e.level+=1,n=0,s=this.properties.length;s>n;n++)o=this.properties[n],r=o.compileToFragments(e),e.level===t||n===u-1||(r=r.concat(",\n"+e.indent)),i=i.concat(r);return e.level-=1,i=i.concat("\n"+e.indent+"}"),i},e.prototype.isComplex=function(){return this.properties.length>0},e.prototype.assigns=function(e){var t,n,r,i;for(r=[],n=0,i=this.properties.length;i>n;n++)t=this.properties[n],r.push(t.assigns(e));return r},e}(),f.Arr=function(){function e(e){this.objects=e}return m(e,f.Base),e.prototype.children=["objects"],e.prototype.isStatement=function(){return!0},e.prototype.compileNode=function(e){var t,n,r,i,s,o;if(s=this.objects.length,t=s>1,t&&(e.multiline=!0),t)for(n=0,i=this.objects.length;i>n;n++)o=this.objects[n],o.isStatement=!0;return t?(e.level+=1,r=this.objects.map(function(t){var n;return n=[e.indent,t.compileNode(e)]})):r=this.objects.map(function(t){return t.compileNode(e)}),[e.idt+"[",r.join(","),e.idt+"]"]},e}(),f.Class=function(){function e(e,t,n){this.variable=e,this.parent=t,this.body=n}return m(e,f.Base),e.prototype.children=["variable","parent","body"],e.prototype.compileNode=function(e){return["class ",this.variable.compileToFragments(e)," extends ",this.parent.compileToFragments(e),this.body.compileToFragments(e)]},e}(),f.Assign=function(){function e(e,t,n){this.variable=e,this.value=t,this.context=n,this.param=!!n&&"param"===n}return m(e,f.Base),e.prototype.children=["variable","value"],e.prototype.isStatement=function(){return this.param?!1:this.value.isStatement()},e.prototype.assigns=function(e){return this.variable.assigns(e)},e.prototype.unfold=function(){var e,t,n;if(this.variable.base.value.match(/=/),t=this.variable.base,t instanceof f.Value&&t.has_properties()){for(n=t.properties,e=0;e<n.length;e++)if(n[e]instanceof f.Access)return[new f.Assign(t.base,this.value)]}else return[new f.Assign(t,this.value)]},e.prototype.compileNode=function(e){var t,n,r;if(t=this.variable.compileToFragments(e),this.value instanceof f.Undefined)return t;n="=";try{this.variable.isAssignable()||this.error("left-hand side of assignment can't be "+this.variable.constructor.name.toLowerCase())}catch(i){r=i,this.unfold(e)}return[t," "+n+" ",this.value.compileToFragments(e)]},e}(),f.Code=function(){function e(e,t,n){this.params=e,this.body=t,this.bound=n}return m(e,f.Base),e.prototype.children=["params","body"],e.prototype.compileNode=function(e){var t,n,r,i,s;return e.sharedScope||(e.scope=new f.Scope(e.scope,this.body,this)),n=this.bound?"=>":"->",t="(",s=0,r=this.params.length;r>s;s++)i=this.params[s],t+=i.compileToFragments(e).join(" ");return t+=") "+n+" ",t+this.body.compileToFragments(e).join("")},e}(),f.If=function(){function e(e,t,n){this.condition=e,this.body=t,this.elseBody=n}return m(e,f.Base),e.prototype.children=["condition","body","elseBody"],e.prototype.isStatement=function(){return!0},e.prototype.compileNode=function(e){return this.isStatement(e)?this.compileStatement(e):this.compileExpression(e)},e.prototype.makeReturn=function(){return this.elseBody=new f.Undefined,this},e.prototype.compileStatement=function(e){var t,n,r;return t=["if (",this.condition.compileToFragments(e),") {",this.body.compileToFragments(e),"} "],this.elseBody&&(n=this.elseBody instanceof f.If?["else ",this.elseBody.compileToFragments(e)]:(r=this.elseBody?this.elseBody.compileToFragments(e):void 0,["else {",r,"}"])),t.concat(n)},e.prototype.compileExpression=function(e){var t,n,r;return t=this.condition.compileToFragments(e),n=this.body.compileToFragments(e),r=this.elseBody.compileToFragments(e),[t," ? ",n," : ",r]},e}(),f.Try=function(){function e(e,t,n,r){this.attempt=e,this.error=t,this.recovery=n,this.ensure=r}return m(e,f.Base),e.prototype.children=["attempt","recovery","ensure"],e.prototype.isStatement=function(){return!0},e.prototype.compileNode=function(e){var t,n;return t=e.scope.freeVariable("error",!1),n=["try {\n",this.attempt.compileToFragments(e,e.level),"\n}"],this.recovery&&n.push(" catch ("+t+") {\n",this.recovery.compileToFragments(e,e.level),"\n}"),this.ensure&&n.push(" finally {\n",this.ensure.compileToFragments(e,e.level),"\n}"),n},e}(),f.Throw=function(){function e(e){this.expression=e}return m(e,f.Base),e.prototype.children=["expression"],e.prototype.isStatement=function(){return!0},e.prototype.compileNode=function(e){return["throw ",this.expression.compileToFragments(e)]},e}(),f.Existence=function(){function e(e){this.expression=e}return m(e,f.Base),e.prototype.children=["expression"],e.prototype.compileNode=function(e){var t,n;return n="!= null",t=this.expression.compileToFragments(e),this.expression.isComplex()&&(t=["(",t,")"]),t.concat([" ",n])},e}(),f.Parenthetical=function(){function e(e){this.expression=e}return m(e,f.Base),e.prototype.children=["expression"],e.prototype.isComplex=function(){return!0},e.prototype.unwrap=function(){return this.expression},e.prototype.compileNode=function(e){var t;return t=this.expression.compileToFragments(e),["(",t,")"]},e}(),f.For=function(){function e(e,t){this.body=e,this.source=t.source,this.guard=t.guard,this.step=t.step,this.name=t.name,this.index=t.index,this.object=!!t.object}return m(e,f.Base),e.prototype.children=["body","source","guard","step"],e.prototype.isStatement=function(){return!0},e.prototype.compileNode=function(e){var n,r,i,s,o,u,a,c,l;return a=this.source.compileToFragments(e),n="i",l=e.scope.freeVariable(this.name.value),c=e.scope.freeVariable(this.index.value),i=this.step,r=this.guard,s=e.idt,u=["var "+l+";"],o=[s+"for ("+n+" in "+a.join("")+") {\n",s+s+l+"="+a.join("")+"["+n+"];\n"],this.guard&&(o=o.concat([s+s+"if ("+r.compileToFragments(e).join("")+") {\n",s+s+s,this.body.compileToFragments(e),s+s+"}\n"])),o=o.concat([s+"}\n"]),u.concat(o)},e}(),f.Switch=function(){function e(e,t,n){this.subject=e,this.cases=t,this.otherwise=n}return m(e,f.Base),e.prototype.children=["subject","cases","otherwise"],e.prototype.isStatement=function(){return!0},e.prototype.compileNode=function(e){var t,n,r,i,s,o,u,a,c;for(u=[],a=[],c=this.subject?this.subject.compileToFragments(e):["true"],u.push("switch ("+c.join("")+") {\n"),i=0,s=this.cases,o=s.length;o>i;i++)n=s[i],r=n[0],t=n[1],u=u.concat([e.idt+"case ",r.compileToFragments(e),":\n",t.compileToFragments(e),"break;\n"]);return this.otherwise&&(u=u.concat([e.idt+"default:\n",this.otherwise.compileToFragments(e),"\n"])),u.push(e.indent+"}")},e}(),f.In=function(){function e(e,t){this.object=e,this.array=t}return m(e,f.Base),e.prototype.children=["object","array"],e.prototype.compileNode=function(e){var t,n;return n=this.array.compileToFragments(e),t=this.object.compileToFragments(e),[t," in ",n]},e.prototype.toString=function(e){var t,n,r;return n=this.array.toString(e),t=this.object.toString(e),r=this.negated?"not in":"in",t+" "+r+" "+n},e}(),f.While=function(){function e(e,t){this.condition=e,this.body=t,this.guard=t}return m(e,f.Base),e.prototype.children=["condition","body"],e.prototype.isStatement=function(){return!0},e.prototype.compileNode=function(e){var t,n,r,i;return n=this.condition,r=this.body,i=this.guard,t=["while ("+n.compileToFragments(e)+") {\n"],i&&(r.expressions.unshift(new f.If(i,new f.Break)),n=new f.Literal("true")),t=t.concat(r.compileToFragments(e)),t=t.concat([e.indent+"}\n"])},e}(),f.Op=function(){function e(e,t,n){var r;return this.operator=e,this.first=t,this.second=n,this.flip=!1,r="Op",f.UNARY_MATH.test(this.operator)&&!this.second?f.UnaryOp:(f.COMPARE.test(this.operator)?r=f.ComparisonOp:"="===this.operator?r=f.AssignOp:f.LOGIC.test(this.operator)?r=f.LogicOp:f.MATH.test(this.operator)?r=f.MathOp:f.RELATION.test(this.operator)&&(r=f.RelationOp),new r(e,t,n))}return m(e,f.Base),e.prototype.children=["first","second"],e.prototype.isSimple=function(){return this.first.isSimple()&&(this.second?this.second.isSimple():!0)},e.prototype.isChainable=function(){var e,t;return t=this.first,e=this.second,"Op"!==t.constructor.name||t.operator!==e.operator?!1:!0},e.prototype.compileNode=function(e){var t,n;return t=this.first.compileToFragments(e),n=this.second.compileToFragments(e),t=this.first.isComplex()?["(",t,")"]:t,n=this.second.isComplex()?["(",n,")"]:n,this.flip?n.concat([" "+this.operator+" "],t):t.concat([" "+this.operator+" "],n)},e}(),f.UnaryOp=function(){function e(e,t){this.operator=e,this.first=t}return m(e,f.Op),e.prototype.children=["first"],e.prototype.compileNode=function(e){var t;return t=this.first.compileToFragments(e),this.first.isComplex()&&(t=["(",t,")"]),[this.operator,t]},e}(),f.ComparisonOp=function(){function e(){return e.__super__.constructor.apply(this,arguments)}return m(e,f.Op),e}(),f.MathOp=function(){function e(){return e.__super__.constructor.apply(this,arguments)}return m(e,f.Op),e}(),f.AssignOp=function(){function e(){return e.__super__.constructor.apply(this,arguments)}return m(e,f.Op),e}(),f.LogicOp=function(){function e(t,n,r){e.__super__.constructor.call(this,t,n,r),this.first=n,this.second=r,this.operator=t}return m(e,f.Op),e}(),f.RelationOp=function(){function e(t,n,r){e.__super__.constructor.call(this,t,n,r),this.first=n,this.second=r,this.operator=t}return m(e,f.Op),e}(),f.Splice=function(){function e(e,t,n){this.range=e,this.value=t,this.exclusive=n}return m(e,f.Base),e.prototype.children=["range","value"],e.prototype.isStatement=function(){return!0},e.prototype.compileNode=function(e){var t,n,r,i;return t=this.range.from.compile(e),n=this.range.to.compile(e),i=this.range.exclusive,r="], "+(i?n:n+"+1")+", "+this.value.compile(e)+").concat(",[".slice.call(this.value.compile(e))+")"],[".splice.apply(",t,", [",n+" - "+t+""+i,"].concat(",this.value.compile(e),"))"]},e}(),f.Super=function(){function e(){e.__super__.constructor.apply(this,arguments)}return m(e,f.Call),e.prototype.compileNode=function(e){return["super","("].concat(this.args.map(function(t){return t.compileToFragments(e)})).concat([")"])},e}(),f.SuperCall=function(){function e(e,t){f.Call.call(this,e,t),this.args=t,this.variable=new f.Value(new f.Literal("super"))}return m(e,f.Call),e}(),f.Slice=function(){function e(e,t){f.Base.call(this,e,t),this.args=t,this.variable=new f.Value(new f.Literal("slice"))}return m(e,f.Call),e}(),f.Block=function(){function e(e){this.expressions=f.helpers.compact(e||[])}return m(e,f.Base),e.prototype.children=["expressions"],e.prototype.isStatement=function(e){var t,n,r,i;for(r=0,i=this.expressions.length;i>r;r++)if(t=this.expressions[r],t.isStatement(e))return!0;return!1},e.prototype.is_empty=function(){return!this.expressions.length},e.prototype.compileNode=function(e){var t,n,r,i;return r=this.expressions.length,t=this.isStatement(e),i=[],t?e.level>0:void 0,this.expressions.map(function(t,s){var o,u,a,c,l;return u=t.makeReturn(),l=u.isStatement(),t=u,o=t.compileToFragments(e),s===r-1&&l&&u instanceof f.Return?o:(c=t instanceof f.Comment,a=t instanceof f.Literal&&t.value==="",n=t instanceof f.Value&&t.base instanceof f.Literal&&t.base.value.match(/=/),c||a?void 0:i.push(o.join("")+";\n"))}),i},e}(),f.Identifier=f.Literal,f.Param=function(){function e(e,t,n){this.name=e,this.value=t,this.splat=n}return m(e,f.Base),e.prototype.children=["name","value"],e.prototype.compileToFragments=function(e){var t;return t=this.name.compileToFragments(e),this.splat&&t.push("..."),this.value&&t.push(" = "+this.value.compileToFragments(e)),t},e}(),f.While=function(){function e(t,n){e.__super__.constructor.call(this,t,n),this.condition=n.condition}return m(e,f.Base),e}(),f.Break=function(){function e(e){this.expression=e}return m(e,f.Return),e}(),f.Continue=function(){function e(e){this.expression=e}return m(e,f.Return),e}(),f.expressions=f.Block,f.Scope=function(){function e(e,t,n){this.parent=e,this.expressions=t,this.method=n,this.variables={},this.positions={},this.line=e?e.line:0,t.traverseChildren(this,!1,function(e){return e.isStatement()?!0:void 0})}return e.prototype.add=function(e,t){return this.shared?this.parent.add(e,t):this.variables[e]||(this.variables[e]=t)},e.prototype.check=function(e){return!(!this.variables[e]&&!this.parent)},e.prototype.freeVariable=function(e,t){var n,r;for(null==t&&(t={}),r=t.reserve;void 0!==(n=this.check(e))&&n!==!1;)e+=t.type?t.type:this.parent?this.parent.valtype:"_";return this.add(e,r?"reserved":"unreserved"),e},e.prototype.assign=function(e,t){return this.add(e,{value:t})},e}(),f.compile=function(e,t){var n,r;return null==t&&(t={}),t.bare||(t.bare=!!t.noWrap),n=new Y,r=new f.Lexer,f.parser.yy=f.nodes,f.parser.lexer=r,f.parser.parse(n.rewrite(r.tokenize(e,t))).compile(t)},f.tokens=function(e,t){return(new f.Lexer).tokenize(e,t)},f.nodes=function(e,t){return"string"==typeof e?f.parser.parse((new f.Lexer).tokenize(e,t)):f.parser.parse(e)},f.run=function(e,t){var n,r;return null==t&&(t={}),n=t.filename,r=f.compile(e,t),t.bare?eval.call(d,r):Function(r)()},f.eval=function(e,t){var n,r,i,s,o;return null==t&&(t={}),"undefined"==typeof $&&(null!=("undefined"!=typeof process&&null!==process?process.versions:void 0)?process.versions.node:void 0)||(t.sandbox?("undefined"!=typeof sandbox&&null!==sandbox||(s=document.getElementsByTagName("iframe"),o=[],function(){for(var e,t=0,n=s.length;n>t;t++)e=s[t],e.id||o.push(e.id="sandbox");return o}(),sandbox=document.getElementById("sandbox"),sandbox||(sandbox=document.createElement("iframe"),sandbox.id="sandbox",sandbox.style.display="none",document.body.appendChild(sandbox))),i=sandbox.contentWindow):i=window,r=i.eval),t.bare||(e="\n"+e.replace(/(__slice\s*=\s*\[\]\.slice)/,"this.$1")+'\n__slice = [].slice\n'),n=f.compile(e,t),r.call(t.context||d,n)},d.CoffeeScript=f,"function"==typeof define&&define.amd&&define(f),"object"==typeof module&&module.exports&&(module.exports=f,module.exports.CoffeeScript=f)}();
/* ========  END  COFFEESCRIPT RUNTIME (PASTE MINIFIED CODE HERE)  ======== */

// ---- math.js exposed as generic_modules/math ----
(function(global){
  var module = {exports: {}};
  var exports = module.exports;
var Epsilon = 0.00000001;

module.exports = {
  /**
   * @author Peter Kelley
   * @author pgkelley4@gmail.com
   */

  /**
   * See if two line segments intersect. This uses the
   * vector cross product approach described below:
   * http://stackoverflow.com/a/565282/786339
   *
   * @param {Object} p point object with x and y coordinates
   *  representing the start of the 1st line.
   * @param {Object} p2 point object with x and y coordinates
   *  representing the end of the 1st line.
   * @param {Object} q point object with x and y coordinates
   *  representing the start of the 2nd line.
   * @param {Object} q2 point object with x and y coordinates
   *  representing the end of the 2nd line.
   */
  doLineSegmentsIntersect: function (p, p2, q, q2, omitEnds) {
    var r = this.subtractPoints(p2, p);
    var s = this.subtractPoints(q2, q);

    var uNumerator = this.crossProduct(this.subtractPoints(q, p), r);
    var denominator = this.crossProduct(r, s);

    if (uNumerator == 0 && denominator == 0) {
      return false;
      // colinear, so do they overlap?
      // return ((q.x - p.x < 0) != (q.x - p2.x < 0) != (q2.x - p.x < 0) != (q2.x - p2.x < 0)) ||
      //   ((q.y - p.y < 0) != (q.y - p2.y < 0) != (q2.y - p.y < 0) != (q2.y - p2.y < 0));
    }

    if (denominator == 0) {
      // lines are paralell
      return false;
    }

    var u = uNumerator / denominator;
    var t = this.crossProduct(this.subtractPoints(q, p), s) / denominator;

    var doSegmentsIntersect;
    if (!omitEnds) {
      doSegmentsIntersect = (t >= 0) && (t <= 1) && (u >= 0) && (u <= 1);
    } else {
       doSegmentsIntersect = (t > 0.001) && (t < 1-0.001) && (u > 0.001) && (u < 1-0.001);
    }

    if (doSegmentsIntersect) {
      return { x: p.x + t * r.x, y: p.y + t * r.y, t: t }
    }

    return doSegmentsIntersect;
  },

  equalV: function(v1, v2) {
    var diff = this.subtractPoints(v1, v2);
    var length2 = this.lengthV2(diff);
    return length2 < Epsilon;
  },

  addPoints: function(point1, point2) {
    var result = {};
    result.x = point1.x + point2.x;
    result.y = point1.y + point2.y;

    return result;
  },

  subtractPoints: function (point1, point2) {
    return {
      x: point1.x - point2.x,
      y: point1.y - point2.y
    }
  },

  crossProduct: function (point1, point2) {
    return point1.x * point2.y - point1.y * point2.x;
  },

  dotProduct: function(point1, point2) {
    return point1.x * point2.x + point1.y * point2.y;
  },

  length: function (point1, point2) {
    var v = this.subtractPoints(point2, point1);
    return this.lengthV(v);
  },

  length2: function (point1, point2) {
    var v = this.subtractPoints(point2, point1);
    return this.lengthV2(v);
  },

  lengthV: function(v) {
    return Math.sqrt(this.lengthV2(v));
  },

  lengthV2: function(v) {
    return v.x * v.x + v.y * v.y;
  },

  angleBetween: function(v1, v2) {
    var angleRad = Math.acos( (v1.x * v2.x + v1.y * v2.y) /
      ( this.lengthV(v1) * this.lengthV(v2) ) );
    var angleDeg = angleRad * 180 / Math.PI;
    return angleDeg;
  },

  sign: function(x) {
    if (x > 0) {
      return 1;
    } else if (x < 0) {
      return -1;
    } else {
      return 0;
    }
  },

  fractionBetween: function (v1, v2, fraction) {
    var v1ToV2 = this.subtractPoints(v2, v1);
    return {x: (v1.x + v1ToV2.x * fraction), y: (v1.y + v1ToV2.y * fraction)}
  },

  sinDegrees: function(deg) {
    return Math.sin(deg * Math.PI / 180);
  },

  cosDegrees: function(deg) {
    return Math.cos(deg * Math.PI / 180);
  },

  atanDegrees: function(val) {
    return Math.atan(val) * 180 / Math.PI;
  },

  randomRange: function(min, max) {
    return Math.random()*(max - min) + min;
  },

  multVScalar: function(v, n) {
    return {x: v.x * n, y: v.y * n};
  },

  divVScalar: function(v, n) {
    return {x: v.x / n, y: v.y / n};
  },

  oldDistanceToLine: function(p, q1, q2) {
    // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
    var qV = this.subtractPoints(q2, q1);
    var length = this.lengthV(qV);
    var qVNorm = this.divVScalar(qV, length);

    var eq2 = this.dotProduct(this.subtractPoints(q1, p), qVNorm);
    var qVNormMult = this.multVScalar(qVNorm, eq2);
    var vToLine = this.subtractPoints(this.subtractPoints(q1, p), qVNormMult);

    return {
      distance: this.lengthV(vToLine),
      pointOnLine: this.addPoints(p, vToLine),
      // distance along line of projected point
      lineProj: -eq2,
      length: length
    };
  },

  newDistanceToLine: function(P, A, B) {
    var AP = this.subtractPoints(P, A);
    var AB = this.subtractPoints(B, A);
    var result = this.project(AP, AB);
    var AD = result.projected;
    var D = this.addPoints(A, AD);

    return {
      distance: this.length(D, P),
      pointOnLine: D,
      // distance along line of projected point
      lineProj: this.sign(result.dotProduct) * this.lengthV(AD) ,
      length: this.lengthV(AB)
    };
  },

  distanceToLine: function(P, A, B) {
    var AP = this.subtractPoints(P, A);
    var AB = this.subtractPoints(B, A);
    var result = this.project(AP, AB);
    var AD = result.projected;
    var D = this.addPoints(A, AD);

    return {
      distance2: this.length2(D, P),
      pointOnLine: D,
      // distance along line of projected point
      lineProj2: this.sign(result.dotProduct) * this.lengthV2(AD) ,
      length2: this.lengthV2(AB)
    };
  },

  project: function(v, onto) {
    // http://en.wikipedia.org/wiki/Vector_projection
    var dotProduct = this.dotProduct(v, onto);
    return {
      dotProduct: dotProduct,
      projected: this.multVScalar(onto, dotProduct / this.lengthV2(onto))
    }
  }
};


  // Register as CommonJS-like module for our in-bundle require shim
  global.__CityGenModules__ = global.__CityGenModules__ || {};
  global.__CityGenModules__['generic_modules/math'] = module.exports;
})(typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : this));

// ---- improved require shim + built-in stubs for offline ----
(function(global){
  var REG = global.__CityGenModules__ = global.__CityGenModules__ || {};

  // Minimal lodash we need
  function lodashFactory(){
    function isArray(a){ return Array.isArray(a); }
    function each(coll, iter){
      if (!coll) return;
      if (isArray(coll)) { for (var i=0;i<coll.length;i++) iter(coll[i], i); }
      else { for (var k in coll) if (Object.prototype.hasOwnProperty.call(coll,k)) iter(coll[k], k); }
    }
    function findIndex(arr, pred){
      for (var i=0;i<arr.length;i++){ if (pred(arr[i], i)) return i; }
      return -1;
    }
    function getter(iter){
      if (typeof iter === 'function') return iter;
      if (typeof iter === 'string') return function(o){ return o && o[iter]; };
      return function(x){ return x; };
    }
    function minBy(arr, iter){
      if (!arr || !arr.length) return undefined;
      var g = getter(iter), min = arr[0], minv = g(min);
      for (var i=1;i<arr.length;i++){ var v=g(arr[i]); if (v < minv){ minv=v; min=arr[i]; } }
      return min;
    }
    function maxBy(arr, iter){
      if (!arr || !arr.length) return undefined;
      var g = getter(iter), max = arr[0], maxv = g(max);
      for (var i=1;i<arr.length;i++){ var v=g(arr[i]); if (v > maxv){ maxv=v; max=arr[i]; } }
      return max;
    }
    function min(arr, iter){ return iter ? minBy(arr, iter) : Math.min.apply(null, arr); }
    function max(arr, iter){ return iter ? maxBy(arr, iter) : Math.max.apply(null, arr); }
    function assign(target){
      for (var i=1;i<arguments.length;i++){
        var src = arguments[i]; if (!src) continue;
        for (var k in src){ if (Object.prototype.hasOwnProperty.call(src,k)) target[k] = src[k]; }
      }
      return target;
    }
    function some(arr, pred){
      for (var i=0;i<arr.length;i++){ if (pred(arr[i], i)) return true; }
      return false;
    }
    function partialRight(fn){
      var rightArgs = Array.prototype.slice.call(arguments,1);
      return function(){
        var args = Array.prototype.slice.call(arguments);
        return fn.apply(this, args.concat(rightArgs));
      };
    }
    function clone(x){ return Array.isArray(x) ? x.slice() : assign({}, x); }
    function cloneDeep(x){ return JSON.parse(JSON.stringify(x)); }

    return {
      cloneDeep: cloneDeep,
      clone: clone,
      assign: assign,
      each: each,
      findIndex: findIndex,
      min: min,
      max: max,
      partialRight: partialRight,
      some: some,
      any: some // alias
    };
  }

  // Simple Quadtree stub (AABB filter)
  function Quadtree(bounds, maxObjects, maxLevels){
    this._bounds = bounds || {x:-1e9,y:-1e9,width:2e9,height:2e9};
    this._items = [];
  }
  Quadtree.prototype.insert = function(entry){ this._items.push(entry); };
  function overlaps(a,b){
    return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
  }
  Quadtree.prototype.retrieve = function(area){
    var out = [];
    for (var i=0;i<this._items.length;i++){
      var it = this._items[i];
      if (!area || overlaps(area, it)) out.push(it);
    }
    return out;
  };

  // Tiny seedrandom replacement
  (function(){
    function makeLCG(seed){
      var s = 0;
      // string seed hash
      var str = String(seed);
      for (var i=0;i<str.length;i++){ s = (s*31 + str.charCodeAt(i))|0; }
      var state = (s>>>0) + 1;
      return function(){
        state = (state * 1664525 + 1013904223) >>> 0;
        return state / 4294967296;
      };
    }
    Math.seedrandom = function(seed){
      var rnd = makeLCG(seed);
      Math.random = rnd;
      return rnd;
    };
  })();

  // Perlin-like stub with seed
  var perlin = (function(){
    var _seed = 0;
    return {
      seed: function(s){ _seed = +s || 0; },
      simplex2: function(x,y){
        var n = Math.sin(x*12.9898 + y*78.233 + _seed*43758.5453);
        var f = n - Math.floor(n);
        return f*2 - 1; // [-1,1]
      }
    };
  })();

  // Simple HashMap wrapper to match .put/.get API
  function HashMap(){
    this._m = new Map();
  }
  HashMap.prototype.put = function(k,v){ this._m.set(k,v); };
  HashMap.prototype.get = function(k){ return this._m.get(k); };
  HashMap.prototype.has = function(k){ return this._m.has(k); };

  // Expose stubs to global for optional external overrides
  global.Quadtree = { Quadtree: Quadtree };
  global.perlin = perlin;
  global.seedrandom = Math.seedrandom; // for require convenience

  // Provide a very small 'PIXI' stub (not used by core logic here)
  global.PIXI = global.PIXI || {};

  // The require shim
  global.require = function(name){
    if (REG[name]) return REG[name];
    // Known aliases used by the original project
    if (name === 'lodash' || name === '_') return global._ || (REG[name] = lodashFactory());
    if (name === 'pixi.js/bin/pixi.js') return global.PIXI || (function(){ throw new Error('PIXI not provided'); })();
    if (name === 'perlin') return global.perlin || (function(){ throw new Error('perlin noise not provided'); })();
    if (name === 'quadtree') return global.Quadtree || (function(){ throw new Error('Quadtree not provided'); })();
    if (name === 'seedrandom') return global.seedrandom || (function(){ throw new Error('seedrandom not provided'); })();
    if (name === 'map') return REG[name] || (REG[name] = HashMap);
    if (name.indexOf('generic_modules/') === 0) throw new Error('Module '+name+' not registered');
    if (name.indexOf('game_modules/') === 0) throw new Error('Module '+name+' not registered');
    throw new Error('Unknown module '+name);
  };
})(typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : this));

// ---- merged CoffeeScript sources (patched to self-register modules) ----
var COFFEE_SRC = "### BEGIN FILE: config.coffee\n\n\n# author: tmwhere.com\n\nmath = require('generic_modules/math')\n\nbranchAngleDev = 3\nforwardAngleDev = 15\nrandomAngle = (limit) ->\n  # non-linear distribution\n  nonUniformNorm = Math.pow(Math.abs(limit), 3)\n  val = 0\n  while (val == 0 || Math.random() < Math.pow(Math.abs(val), 3)/nonUniformNorm)\n    val = math.randomRange(-limit, +limit)\n  return val\n\nconfigVariables = {\n  mapGeneration:\n    BUILDING_PLACEMENT_LOOP_LIMIT: 3 # by the nth iteration of building placement no further collisions are allowed\n    DEFAULT_SEGMENT_LENGTH: 300\n    HIGHWAY_SEGMENT_LENGTH: 400\n    DEFAULT_SEGMENT_WIDTH: 6\n    HIGHWAY_SEGMENT_WIDTH: 16\n    RANDOM_BRANCH_ANGLE: ->\n      randomAngle(branchAngleDev)\n    RANDOM_STRAIGHT_ANGLE: ->\n      randomAngle(forwardAngleDev)\n    DEFAULT_BRANCH_PROBABILITY: 0.4\n    HIGHWAY_BRANCH_PROBABILITY: 0.05\n    HIGHWAY_BRANCH_POPULATION_THRESHOLD: 0.1\n    NORMAL_BRANCH_POPULATION_THRESHOLD: 0.1\n    NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY: 5\n    MINIMUM_INTERSECTION_DEVIATION: 30 # degrees\n    SEGMENT_COUNT_LIMIT: 2000\n    DEBUG_DELAY: 0 # ms\n    ROAD_SNAP_DISTANCE: 50\n    HEAT_MAP_PIXEL_DIM: 50 # px\n    DRAW_HEATMAP: false\n    QUADTREE_PARAMS:\n      x: -20000\n      y: -20000\n      width: 40000\n      height: 40000\n    QUADTREE_MAX_OBJECTS: 10\n    QUADTREE_MAX_LEVELS: 10\n    DEBUG: false\n  gameLogic:\n    SELECT_PAN_THRESHOLD: 50 # px, limit beyond which a click becomes a drag\n    SELECTION_RANGE: 50 # px\n    DEFAULT_PICKUP_RANGE: 150 # world units\n    DEFAULT_CARGO_CAPACITY: 1\n    MIN_SPEED_PROPORTION: 0.1 # the minimum reduction of the speed of a road when congested\n}\n\n# register module (instead of module.exports)\nroot = if typeof window isnt 'undefined' then window else if typeof self isnt 'undefined' then self else this\nroot.__CityGenModules__ ?= {}\nroot.__CityGenModules__['game_modules/config'] = do ->\n  return configVariables\n\n\n### BEGIN FILE: utility.coffee\n\n\n_ = require('lodash')\n\n# register module\nroot = if typeof window isnt 'undefined' then window else if typeof self isnt 'undefined' then self else this\nroot.__CityGenModules__ ?= {}\nroot.__CityGenModules__['generic_modules/utility'] =\n  defaultFor: (arg, val, deep) ->\n    argCopy = if deep then _.cloneDeep(arg) else arg\n    valCopy = if deep then _.cloneDeep(val) else val\n    if typeof arg != 'undefined' then argCopy else valCopy\n\n  joinArrayGeneric: (array, joinElement) ->\n    copy = array.slice(0)\n    for i in [1...copy.length * 2 - 1] by 2\n      copy.splice(i, 0, joinElement)\n    return copy\n    \n\n  addArrayPushListener: (array, callback) ->\n    array.push = ->\n      for i in [0..arguments.length-1] by 1\n          this[@length] = arguments[i]\n          callback()\n      return this.length\n\n  minDegreeDifference: (d1, d2) ->\n    diff = Math.abs(d1 - d2) % 180\n    return Math.min(diff, Math.abs(diff-180))\n\n  extendedMin: (collection, selector) ->\n    if (!selector?)\n      selector = (obj) -> obj\n\n    minObj = undefined\n    minObj_i = 0\n    _.each(collection, (obj, i) ->\n      if (!minObj? || selector(obj) < selector(minObj)) \n        minObj = obj\n        minObj_i = i\n    )\n    return [minObj, minObj_i]\n\n  extendedMax: (collection, selector) ->\n    if (!selector?)\n      selector = (obj) -> obj\n\n    maxObj = undefined\n    maxObj_i = 0\n    _.each(collection, (obj, i) ->\n      if (!maxObj? || selector(obj) > selector(maxObj)) \n        maxObj = obj\n        maxObj_i = i\n    )\n    return [maxObj, maxObj_i]\n\n  PriorityQueue:\n    class PriorityQueue\n      constructor: ->\n        @list = []\n\n      put: (item, priority) ->\n        newPair =\n          item: item\n          priority: priority\n\n        index = _.findIndex(@list, (pair) ->\n          pair.priority > newPair.priority\n        )\n        if (index == - 1)\n          @list.push(newPair)\n        else\n          @list.splice(index, 0, newPair)\n        \n      get: ->\n        @list.shift().item\n\n      length: ->\n        @list.length\n\n### BEGIN FILE: collision.coffee\n\n\n# author: tmwhere.com\n\n_ = require('lodash')\n\nmath = require('generic_modules/math')\nutil = require('generic_modules/utility')\n\n# register module\nroot = if typeof window isnt 'undefined' then window else if typeof self isnt 'undefined' then self else this\nroot.__CityGenModules__ ?= {}\nroot.__CityGenModules__['generic_modules/collision'] =\n  CollisionObject:\n    class CollisionObject\n      @Type:\n        RECT: \"rect\"\n        LINE: \"line\"\n        CIRCLE: \"circle\"\n\n      constructor: (@o, @collisionType, @collisionProperties) ->\n        @collisionRevision = 0\n        @limitsRevision = undefined\n\n        @cachedLimits = undefined\n\n      updateCollisionProperties: (props) ->\n        @collisionRevision++\n        @collisionProperties = _.assign(@collisionProperties, props)\n\n      limits: ->\n        if (@collisionRevision != @limitsRevision)\n          @limitsRevision = @collisionRevision\n          @cachedLimits = switch @collisionType\n            when CollisionObject.Type.RECT\n              minX = _.min(@collisionProperties.corners, 'x').x\n              minY = _.min(@collisionProperties.corners, 'y').y\n              @cachedLimits =\n                x: minX\n                y: minY\n                width: _.max(@collisionProperties.corners, 'x').x - minX\n                height: _.max(@collisionProperties.corners, 'y').y - minY\n                o: @o\n            when CollisionObject.Type.LINE\n              x: Math.min(@collisionProperties.start.x, @collisionProperties.end.x)\n              y: Math.min(@collisionProperties.start.y, @collisionProperties.end.y)\n              width: Math.abs(@collisionProperties.start.x - @collisionProperties.end.x)\n              height: Math.abs(@collisionProperties.start.y - @collisionProperties.end.y)\n              o: @o\n            when CollisionObject.Type.CIRCLE\n              x: @collisionProperties.center.x - @collisionProperties.radius\n              y: @collisionProperties.center.y - @collisionProperties.radius\n              width: @collisionProperties.radius * 2\n              height: @collisionProperties.radius * 2\n              o: @o\n\n        return @cachedLimits\n\n      collide: (other) ->\n        # avoid expensive collision check if possible\n        objLimits = @limits()\n        otherLimits = other.limits()\n        if (objLimits? && otherLimits? &&\n        (objLimits.x + objLimits.width < otherLimits.x || otherLimits.x + otherLimits.width < objLimits.x) &&\n        (objLimits.y + objLimits.height < otherLimits.y || otherLimits.y + otherLimits.height < objLimits.y))\n          return false\n\n        switch @collisionType\n          when CollisionObject.Type.CIRCLE\n            switch other.collisionType\n              when CollisionObject.Type.RECT\n                @rectCircleCollision(other.collisionProperties, @collisionProperties)\n          when CollisionObject.Type.RECT\n            switch other.collisionType\n              when CollisionObject.Type.RECT\n                @rectRectIntersection(@collisionProperties, other.collisionProperties)\n              when CollisionObject.Type.LINE\n                @rectRectIntersection(@collisionProperties, @rectPropsFromLine(other.collisionProperties))\n              when CollisionObject.Type.CIRCLE\n                @rectCircleCollision(@collisionProperties, other.collisionProperties)\n          when CollisionObject.Type.LINE\n            switch other.collisionType\n              when CollisionObject.Type.RECT\n                @rectRectIntersection(@rectPropsFromLine(@collisionProperties), other.collisionProperties)\n              when CollisionObject.Type.LINE\n                @rectRectIntersection(@rectPropsFromLine(@collisionProperties), @rectPropsFromLine(other.collisionProperties))\n\n      rectCircleCollision: (rectProps, circleProps) ->\n        corners = rectProps.corners\n\n        # check for corner intersections with circle\n        for i in [0...corners.length] by 1\n          if (math.length2(corners[i], circleProps.center) <= circleProps.radius * circleProps.radius)\n            return true\n\n        # check for edge intersections with circle\n        # from http://stackoverflow.com/a/1079478\n        for i in [0...corners.length] by 1\n          start = corners[i]\n          end = corners[(i + 1) % corners.length]\n          {distance2, lineProj2, length2} = math.distanceToLine(circleProps.center, start, end)\n          if (lineProj2 > 0 && lineProj2 < length2 && distance2 <= circleProps.radius * circleProps.radius)\n            return true\n\n        # check that circle is not enclosed by rectangle\n        axes = [\n          math.subtractPoints(corners[3], corners[0])\n          math.subtractPoints(corners[3], corners[2])\n        ]\n\n        projections = [\n          math.project(math.subtractPoints(circleProps.center, corners[0]), axes[0])\n          math.project(math.subtractPoints(circleProps.center, corners[2]), axes[1])\n        ]\n\n        if (projections[0].dotProduct < 0 || math.lengthV2(projections[0].projected) > math.lengthV2(axes[0]) ||\n        projections[1].dotProduct < 0 || math.lengthV2(projections[1].projected) > math.lengthV2(axes[1]))\n          return false\n\n        return true\n\n      rectPropsFromLine: (lineProps) ->\n        dir = math.subtractPoints(lineProps.end, lineProps.start)\n        perpDir = {x: -dir.y, y: dir.x}\n        halfWidthPerpDir = math.multVScalar(perpDir, 0.5 * lineProps.width / math.lengthV(perpDir))\n        tempRectProps =\n          corners: [\n            math.addPoints(lineProps.start, halfWidthPerpDir),\n            math.subtractPoints(lineProps.start, halfWidthPerpDir),\n            math.subtractPoints(lineProps.end, halfWidthPerpDir),\n            math.addPoints(lineProps.end, halfWidthPerpDir)\n          ]\n\n      rectRectIntersection: (rectAProps, rectBProps) ->\n\n        cA = rectAProps.corners\n        cB = rectBProps.corners\n        # generate axes\n        axes = [\n          math.subtractPoints(cA[3], cA[0]),\n          math.subtractPoints(cA[3], cA[2]),\n          math.subtractPoints(cB[0], cB[1]),\n          math.subtractPoints(cB[0], cB[3])\n        ]\n\n        # list used to find axis with the minimum overlap\n        # that axis is used as the response translation vector\n        axisOverlaps = []\n\n        for axis in axes\n          # project rectangle points to axis\n          projectedVectorsA = []\n          projectedVectorsB = []\n\n          for corner in cA\n            projectedVectorsA.push(math.project(corner, axis).projected)\n          for corner in cB\n            projectedVectorsB.push(math.project(corner, axis).projected)\n\n          # calculate relative positions of rectangles on axis\n          positionsOnAxisA = []\n          positionsOnAxisB = []\n\n          for v in projectedVectorsA\n            positionsOnAxisA.push(math.dotProduct(v, axis))\n          for v in projectedVectorsB\n            positionsOnAxisB.push(math.dotProduct(v, axis))\n\n          [maxA, maxA_i] = util.extendedMax(positionsOnAxisA)\n          [minA, minA_i] = util.extendedMin(positionsOnAxisA)\n          [maxB, maxB_i] = util.extendedMax(positionsOnAxisB)\n          [minB, minB_i] = util.extendedMin(positionsOnAxisB)\n          # if the rectangles don't overlap on at least one axis\n          # they are not colliding\n          if (maxA < minB || maxB < minA)\n            return false\n          else\n            # calculate the overlap between the rectangles on this axis\n            diff1 = math.subtractPoints(projectedVectorsA[maxA_i], projectedVectorsB[minB_i])\n            diff2 = math.subtractPoints(projectedVectorsB[maxB_i], projectedVectorsA[minA_i])\n\n            if (math.lengthV2(diff1) < math.lengthV2(diff2))\n              axisOverlaps.push(diff1)\n            else\n              # the rectangles overlap on the other side\n              # invert the vector so that it will push out of the collision\n              axisOverlaps.push(math.multVScalar(diff2, -1))\n\n        # find axis with the minimum overlap\n        minVector = _.min(axisOverlaps, (v) ->\n          math.lengthV2(v)\n        )\n\n        # return displacement required to pull rectA from collision\n        return math.multVScalar(minVector, -1)\n\n\n### BEGIN FILE: astar.coffee\n\n\n# author: tmwhere.com\n\nutil = require('generic_modules/utility')\nHashMap = require('map')\n\n# register module\nroot = if typeof window isnt 'undefined' then window else if typeof self isnt 'undefined' then self else this\nroot.__CityGenModules__ ?= {}\nroot.__CityGenModules__['generic_modules/astar'] =\n  PathLocation:\n    class PathLocation\n      constructor: (@o, @fraction) ->\n\n  calc: do ->\n    cost = (current, next, start, end) ->\n      currentFraction = undefined\n      nextFraction = undefined\n      if (start.o == end.o)\n        fraction = Math.abs(start.fraction - end.fraction)\n        return fraction * current.cost()\n      else\n        if (current == start.o)\n          currentFraction = start.fraction\n        if (next == end.o)\n          nextFraction = end.fraction\n      return current.costTo(next, currentFraction) + next.costTo(current, nextFraction)\n\n    {\n      find: (start, end) ->\n        frontier = new util.PriorityQueue\n        frontier.put(start.o, 0)\n        came_from = new HashMap\n        came_from.put(start.o, null)\n        cost_so_far = new HashMap\n        cost_so_far.put(start.o, 0)\n\n        while (frontier.length() > 0)\n          current = frontier.get()\n\n          if current == end.o\n            break\n\n          for next in current.neighbours()\n            new_cost = cost_so_far.get(current) + cost(current, next, start, end)\n            if !cost_so_far.get(next)? || new_cost < cost_so_far.get(next)\n              cost_so_far.put(next, new_cost)\n              priority = new_cost # + heuristic(goal, next)\n              frontier.put(next, priority)\n              came_from.put(next, current)\n\n        console.log(\"path cost: #{cost_so_far.get(end.o)}\")\n        # reconstruct path\n        current = end.o\n        path = [current]\n        while current != start.o\n          current = came_from.get(current)\n          path.unshift(current)\n\n        return path\n    }\n\n\n### BEGIN FILE: mapgen.coffee\n\n\n# author: tmwhere.com\n\nPIXI = require('pixi.js/bin/pixi.js')\n_ = require('lodash')\n\nnoise = require('perlin').noise\nQuadtree = require('quadtree').Quadtree\nseedrandom = require('seedrandom')\n\nmath = require('generic_modules/math')\nutil = require('generic_modules/utility')\ncollision = require('generic_modules/collision')\n\nconfig = require('game_modules/config')\n\nclass Segment extends collision.CollisionObject\n  @End:\n    START: \"start\"\n    END: \"end\"\n\n  constructor: (start, end, t, q) ->\n    obj = @\n\n    start = _.cloneDeep(start)\n    end = _.cloneDeep(end)\n    t = util.defaultFor(t, 0)\n    q = util.defaultFor(q, {}, true)\n\n    @width = if q.highway then config.mapGeneration.HIGHWAY_SEGMENT_WIDTH else config.mapGeneration.DEFAULT_SEGMENT_WIDTH\n    @collider = new collision.CollisionObject(this, collision.CollisionObject.Type.LINE, {start: start, end: end, width: @width})\n\n    @roadRevision = 0\n    @dirRevision = undefined\n    @lengthRevision = undefined\n\n    @cachedDir = undefined\n    @cachedLength = undefined\n\n    # representation of road\n    @r =\n      start: start\n      end: end\n      setStart: (val) ->\n        @start = val\n        obj.collider.updateCollisionProperties({start: @start})\n        obj.roadRevision++\n      setEnd: (val) ->\n        @end = val\n        obj.collider.updateCollisionProperties({end: @end})\n        obj.roadRevision++\n\n    # time-step delay before this road is evaluated\n    @t = t\n    # meta-information relevant to global goals\n    @q = q\n    # links backwards and forwards\n    @links =\n      b: []\n      f: []\n\n    @users = []\n    [@maxSpeed, @capacity] =\n      if (q.highway)\n        [1200, 12]\n      else\n        [800, 6]\n\n  currentSpeed: ->\n    # subtract 1 from users length so that a single user can go full speed\n    Math.min(config.gameLogic.MIN_SPEED_PROPORTION, 1 - Math.max(0, @users.length - 1) / @capacity) * @maxSpeed\n\n  # clockwise direction\n  dir: ->\n    if (@dirRevision != @roadRevision)\n      @dirRevision = @roadRevision\n      vector = math.subtractPoints(@r.end, @r.start)\n      @cachedDir = -1 * math.sign(math.crossProduct({x:0, y: 1}, vector)) * math.angleBetween({x: 0, y: 1}, vector)\n    return @cachedDir\n\n  length: ->\n    if (@lengthRevision != @roadRevision)\n      @lengthRevision = @roadRevision\n      @cachedLength = math.length(@r.start, @r.end)\n    return @cachedLength\n\n  debugLinks: ->\n    @q.color = 0x00FF00\n    _.each(@links.b, (backwards) ->\n      backwards.q.color = 0xFF0000\n    )\n    _.each(@links.f, (forwards) ->\n      forwards.q.color = 0x0000FF\n    )\n\n  startIsBackwards: ->\n    if (@links.b.length > 0)\n      math.equalV(@links.b[0].r.start, @r.start) ||\n      math.equalV(@links.b[0].r.end, @r.start)\n    else\n      math.equalV(@links.f[0].r.start, @r.end) ||\n      math.equalV(@links.f[0].r.end, @r.end)\n\n  cost: ->\n    @length() / @currentSpeed()\n\n  costTo: (other, fromFraction) ->\n    segmentEnd = @endContaining(other)\n    return @cost() *\n      if fromFraction?\n        switch segmentEnd\n          when Segment.End.START then fromFraction\n          when Segment.End.END then (1-fromFraction)\n      else\n        0.5\n\n  neighbours: ->\n    @links.f.concat(@links.b)\n\n  endContaining: (segment) ->\n    startBackwards = @startIsBackwards()\n    if @links.b.indexOf(segment) != -1\n      return if startBackwards then Segment.End.START else Segment.End.END\n    else if @links.f.indexOf(segment) != -1\n      return if startBackwards then Segment.End.END else Segment.End.START\n    else\n      undefined\n\n  linksForEndContaining: (segment) ->\n    if @links.b.indexOf(segment) != -1\n      @links.b\n    else if @links.f.indexOf(segment) != -1\n      @links.f\n    else\n      undefined\n\n  split: (point, segment, segmentList, qTree) ->\n    startIsBackwards = @startIsBackwards()\n\n    splitPart = segmentFactory.fromExisting(this)\n    addSegment(splitPart, segmentList, qTree)\n    splitPart.r.setEnd(point)\n    @r.setStart(point)\n\n    # links are not copied using the preceding factory method\n    # copy link array for the split part, keeping references the same\n    splitPart.links.b = @links.b.slice(0)\n    splitPart.links.f = @links.f.slice(0)\n\n    # work out which links correspond to which end of the split segment\n    if (startIsBackwards)\n      firstSplit = splitPart\n      secondSplit = this\n      fixLinks = splitPart.links.b\n    else\n      firstSplit = this\n      secondSplit = splitPart\n      fixLinks = splitPart.links.f\n\n    _.each(fixLinks, (link) ->\n      index = link.links.b.indexOf(this)\n      if (index != -1)\n        link.links.b[index] = splitPart\n      else\n        index = link.links.f.indexOf(this)\n        link.links.f[index] = splitPart\n    , this)\n    firstSplit.links.f = []\n    firstSplit.links.f.push(segment)\n    firstSplit.links.f.push(secondSplit)\n\n    secondSplit.links.b = []\n    secondSplit.links.b.push(segment)\n    secondSplit.links.b.push(firstSplit)\n\n    segment.links.f.push(firstSplit)\n    segment.links.f.push(secondSplit)\n\nsegmentFactory = do ->\n  return {\n    fromExisting: (segment, t, r, q) ->\n      t = util.defaultFor(t, segment.t)\n      r = util.defaultFor(r, segment.r)\n      q = util.defaultFor(q, segment.q)\n\n      return new Segment(r.start, r.end, t, q)\n    ,\n    usingDirection: (start, dir, length, t, q) ->\n      # default to east\n      dir = util.defaultFor(dir, 90)\n      length = util.defaultFor(length, config.mapGeneration.DEFAULT_SEGMENT_LENGTH)\n\n      end =\n        x: start.x + length*math.sinDegrees(dir),\n        y: start.y + length*math.cosDegrees(dir)\n      return new Segment(start, end, t, q)\n  }\n\nheatmap = do ->\n  {\n    popOnRoad: (r) ->\n      (@populationAt(r.start.x, r.start.y) + @populationAt(r.end.x, r.end.y))/2\n    populationAt: (x, y) ->\n      value1 = (noise.simplex2(x/10000, y/10000) + 1) / 2\n      value2 = (noise.simplex2(x/20000 + 500, y/20000 + 500) + 1) / 2\n      value3 = (noise.simplex2(x/20000 + 1000, y/20000 + 1000) + 1) / 2\n      Math.pow((value1 * value2 + value3) / 2, 2)\n  }\n\ndoRoadSegmentsIntersect = (r1, r2) ->\n  math.doLineSegmentsIntersect(r1.start, r1.end, r2.start, r2.end, true)\n\nlocalConstraints = (segment, segments, qTree, debugData) ->\n  action =\n    priority: 0,\n    func: undefined,\n    q: {}\n\n  matches = qTree.retrieve(segment.collider.limits())\n  for i in [0..matches.length-1] by 1\n    other = matches[i].o\n\n    # intersection check\n    if (action.priority <= 4)\n      intersection = doRoadSegmentsIntersect(segment.r, other.r)\n      if (intersection)\n        if (!action.q.t? || intersection.t < action.q.t)\n          action.q.t = intersection.t\n\n          do (other, intersection) ->\n            action.priority = 4\n            action.func = ->\n              # if intersecting lines are too similar don't continue\n              if util.minDegreeDifference(other.dir(), segment.dir()) < config.mapGeneration.MINIMUM_INTERSECTION_DEVIATION\n                return false\n\n              other.split(intersection, segment, segments, qTree)\n              segment.r.end = intersection\n              segment.q.severed = true\n\n              if (debugData?)\n                if (!debugData.intersections?)\n                  debugData.intersections = []\n                debugData.intersections.push(\n                  x: intersection.x\n                  y: intersection.y\n                )\n\n              return true\n\n    # snap to crossing within radius check\n    if (action.priority <= 3)\n      # current segment's start must have been checked to have been created.\n      # other segment's start must have a corresponding end.\n      if (math.length(segment.r.end, other.r.end) <= config.mapGeneration.ROAD_SNAP_DISTANCE)\n\n        do (other) ->\n          point = other.r.end\n          action.priority = 3\n          action.func = ->\n            segment.r.end = point\n            segment.q.severed = true\n\n            # update links of otherSegment corresponding to other.r.end\n            links = if other.startIsBackwards() then other.links.f else other.links.b\n            # check for duplicate lines, don't add if it exists\n            # this should be done before links are setup, to avoid having to undo that step\n            if _.any(links, (link) ->\n              ((math.equalV(link.r.start, segment.r.end) && math.equalV(link.r.end, segment.r.start)) ||\n              (math.equalV(link.r.start, segment.r.start) && math.equalV(link.r.end, segment.r.end))))\n              return false\n\n            _.each(links, (link) ->\n              # pick links of remaining segments at junction corresponding to other.r.end\n              link.linksForEndContaining(other).push(segment)\n\n              # add junction segments to snapped segment\n              segment.links.f.push(link)\n            )\n\n            links.push(segment)\n            segment.links.f.push(other)\n\n            if (debugData?)\n              if (!debugData.snaps?)\n                debugData.snaps = []\n              debugData.snaps.push(\n                x: point.x\n                y: point.y\n              )\n\n            return true\n\n    # intersection within radius check\n    if (action.priority <= 2)\n\n      {distance2, pointOnLine, lineProj2, length2} = math.distanceToLine(segment.r.end, other.r.start, other.r.end)\n      if (distance2 < config.mapGeneration.ROAD_SNAP_DISTANCE * config.mapGeneration.ROAD_SNAP_DISTANCE &&\n      lineProj2 >= 0 && lineProj2 <= length2)\n\n        do (other) ->\n          point = pointOnLine\n          action.priority = 2\n          action.func = ->\n            segment.r.end = point\n            segment.q.severed = true\n\n            # if intersecting lines are too similar don't continue\n            if util.minDegreeDifference(other.dir(), segment.dir()) < config.mapGeneration.MINIMUM_INTERSECTION_DEVIATION\n              return false\n\n            other.split(point, segment, segments, qTree)\n\n            if (debugData?)\n              if (!debugData.intersectionsRadius?)\n                debugData.intersectionsRadius = []\n              debugData.intersectionsRadius.push(\n                x: point.x\n                y: point.y\n              )\n\n            return true\n\n  if (action.func)\n    return action.func()\n\n  return true\n\nglobalGoals = do ->\n  return {\n    generate: (previousSegment) ->\n      newBranches = []\n      if (!previousSegment.q.severed)\n\n        template = (direction, length, t, q) ->\n            segmentFactory.usingDirection(previousSegment.r.end, direction, length, t, q)\n\n        # used for highways or going straight on a normal branch\n        templateContinue = _.partialRight(template, previousSegment.length(), 0, previousSegment.q)\n        # not using q, i.e. not highways\n        templateBranch = _.partialRight(\n          template, config.mapGeneration.DEFAULT_SEGMENT_LENGTH, if previousSegment.q.highway then config.mapGeneration.NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY else 0)\n\n        continueStraight = templateContinue(previousSegment.dir())\n        straightPop = heatmap.popOnRoad(continueStraight.r)\n\n        if (previousSegment.q.highway)\n          randomStraight = templateContinue(previousSegment.dir() + config.mapGeneration.RANDOM_STRAIGHT_ANGLE())\n\n          randomPop = heatmap.popOnRoad(randomStraight.r)\n          if (randomPop > straightPop)\n            newBranches.push(randomStraight)\n            roadPop = randomPop\n          else\n            newBranches.push(continueStraight)\n            roadPop = straightPop\n          if (roadPop > config.mapGeneration.HIGHWAY_BRANCH_POPULATION_THRESHOLD)\n\n            if (Math.random() < config.mapGeneration.HIGHWAY_BRANCH_PROBABILITY)\n              leftHighwayBranch = templateContinue(previousSegment.dir() - 90 + config.mapGeneration.RANDOM_BRANCH_ANGLE())\n              newBranches.push(leftHighwayBranch)\n            else if (Math.random() < config.mapGeneration.HIGHWAY_BRANCH_PROBABILITY)\n              rightHighwayBranch = templateContinue(previousSegment.dir() + 90 + config.mapGeneration.RANDOM_BRANCH_ANGLE())\n              newBranches.push(rightHighwayBranch)\n\n        else if (straightPop > config.mapGeneration.NORMAL_BRANCH_POPULATION_THRESHOLD)\n          newBranches.push(continueStraight)\n\n        if (straightPop > config.mapGeneration.NORMAL_BRANCH_POPULATION_THRESHOLD)\n          if (Math.random() < config.mapGeneration.DEFAULT_BRANCH_PROBABILITY)\n            leftBranch = templateBranch(previousSegment.dir() - 90 + config.mapGeneration.RANDOM_BRANCH_ANGLE())\n            newBranches.push(leftBranch)\n          else if (Math.random() < config.mapGeneration.DEFAULT_BRANCH_PROBABILITY)\n            rightBranch = templateBranch(previousSegment.dir() + 90 + config.mapGeneration.RANDOM_BRANCH_ANGLE())\n            newBranches.push(rightBranch)\n\n      for i in [0..newBranches.length-1] by 1\n        do (branch = newBranches[i]) ->\n          branch.setupBranchLinks = ->\n            # setup links between each current branch and each existing branch stemming from the previous segment\n            _.each(previousSegment.links.f, (link) ->\n              @links.b.push(link)\n              link.linksForEndContaining(previousSegment).push(this)\n            , @)\n\n            previousSegment.links.f.push(@)\n            @links.b.push(previousSegment)\n\n      return newBranches\n  }\n\naddSegment = (segment, segmentList, qTree) ->\n  segmentList.push(segment)\n  qTree.insert(segment.collider.limits())\n\ngenerate = (seed) ->\n  debugData = {}\n\n  Math.seedrandom(seed)\n  # this perlin noise library only supports 65536 different seeds\n  noise.seed(Math.random())\n\n  priorityQ = []\n  # setup first segments in queue\n  do ->\n    rootSegment = new Segment({x: 0, y: 0}, {x: config.mapGeneration.HIGHWAY_SEGMENT_LENGTH, y: 0}, 0, {highway: true})\n    oppositeDirection = segmentFactory.fromExisting(rootSegment)\n    newEnd =\n      x: rootSegment.r.start.x - config.mapGeneration.HIGHWAY_SEGMENT_LENGTH\n      y: oppositeDirection.r.end.y\n    oppositeDirection.r.setEnd(newEnd)\n    oppositeDirection.links.b.push(rootSegment)\n    rootSegment.links.b.push(oppositeDirection)\n    priorityQ.push(rootSegment)\n    priorityQ.push(oppositeDirection)\n\n  segments = []\n  qTree = new Quadtree(config.mapGeneration.QUADTREE_PARAMS,\n    config.mapGeneration.QUADTREE_MAX_OBJECTS, config.mapGeneration.QUADTREE_MAX_LEVELS)\n\n  while (priorityQ.length > 0 && segments.length < config.mapGeneration.SEGMENT_COUNT_LIMIT)\n    # pop smallest r(ti, ri, qi) from Q (i.e., smallest ‘t’)\n    minT = undefined\n    minT_i = 0\n    _.each(priorityQ, (segment, i) ->\n      if (!minT? || segment.t < minT)\n        minT = segment.t\n        minT_i = i\n    )\n\n    minSegment = priorityQ.splice(minT_i, 1)[0]\n\n    accepted = localConstraints(minSegment, segments, qTree, debugData)\n    if (accepted)\n      if (minSegment.setupBranchLinks?)\n        minSegment.setupBranchLinks()\n      addSegment(minSegment, segments, qTree)\n      _.each(globalGoals.generate(minSegment), (newSegment) ->\n        newSegment.t = minSegment.t + 1 + newSegment.t\n        priorityQ.push(newSegment)\n      )\n\n  id = 0\n  for segment in segments\n    segment.id = id++\n\n  console.log(\"#{segments.length} segments generated.\")\n\n  return {\n    segments: segments\n    qTree: qTree\n    heatmap: heatmap\n    debugData: debugData\n  }\n\n# register module\nroot = if typeof window isnt 'undefined' then window else if typeof self isnt 'undefined' then self else this\nroot.__CityGenModules__ ?= {}\nroot.__CityGenModules__['game_modules/mapgen'] = {\n  Segment: Segment\n  generate: generate\n}\n\n\n### BEGIN FILE: build.coffee\n\n\n# author: tmwhere.com\n\n_ = require('lodash')\n\nastar = require('generic_modules/astar')\ncollision = require('generic_modules/collision')\nmath = require('generic_modules/math')\nutil = require('generic_modules/utility')\n\nconfig = require('game_modules/config')\nmapgen = require('game_modules/mapgen')\n\nclass Building\n  @Type:\n    RESIDENTIAL: \"residential\"\n    IMPORT: \"import\"\n\n  @id: 0\n\n  constructor: (@center, @dir, @diagonal, @type, aspectRatio) ->\n    obj = @\n\n    aspectRatio = util.defaultFor(aspectRatio, 1)\n    # degrees to deviate either end to produce desired aspect ratio\n    @aspectDegree = math.atanDegrees(aspectRatio)\n    @corners = @generateCorners()\n\n    @collider = new collision.CollisionObject(this, collision.CollisionObject.Type.RECT, {corners: @corners})\n\n    @supply = []\n    @demand = []\n\n    @id = Building.id\n    Building.id += 1\n\n  generateCorners: ->\n    [\n      { x: @center.x + @diagonal * math.sinDegrees(+@aspectDegree + @dir), y: @center.y + @diagonal * math.cosDegrees(+@aspectDegree + @dir) }\n      { x: @center.x + @diagonal * math.sinDegrees(-@aspectDegree + @dir),  y: @center.y + @diagonal * math.cosDegrees(-@aspectDegree + @dir) }\n      { x: @center.x + @diagonal * math.sinDegrees(180 + @aspectDegree + @dir), y: @center.y + @diagonal * math.cosDegrees(180 + @aspectDegree + @dir) }\n      { x: @center.x + @diagonal * math.sinDegrees(180 - @aspectDegree + @dir), y: @center.y + @diagonal * math.cosDegrees(180 - @aspectDegree + @dir) }\n    ]\n\n  setCenter: (val) ->\n    @center = val\n    @corners = @generateCorners()\n    @collider.updateCollisionProperties({corners: @corners})\n\n  setDir: (val) ->\n    @dir = val\n    @corners = @generateCorners()\n    @collider.updateCollisionProperties({corners: @corners})\n\nbuildingsInRangeOf = (location, qTree) ->\n  {x, y} = location\n  matches = qTree.retrieve({\n    x: x - config.gameLogic.DEFAULT_PICKUP_RANGE\n    y: y - config.gameLogic.DEFAULT_PICKUP_RANGE\n    width: config.gameLogic.DEFAULT_PICKUP_RANGE * 2\n    height: config.gameLogic.DEFAULT_PICKUP_RANGE * 2\n  })\n\n  buildings = []\n  range = new collision.CollisionObject(undefined, collision.CollisionObject.Type.CIRCLE,\n    {center: {x: x, y: y}, radius: config.gameLogic.DEFAULT_PICKUP_RANGE})\n\n  _.each(matches, (match) ->\n    # if it's a building\n    if (match.o.supply? && match.o.demand? && range.collide(match.o.collider))\n      buildings.push(match.o)\n  )\n\n  return buildings\n\n# register module\nroot = if typeof window isnt 'undefined' then window else if typeof self isnt 'undefined' then self else this\nroot.__CityGenModules__ ?= {}\nroot.__CityGenModules__['game_modules/build'] =\n  buildingFactory: do ->\n    {\n      fromProbability: (time) ->\n        if Math.random() < 0.4\n          return @byType(Building.Type.IMPORT, time)\n        else\n          return @byType(Building.Type.RESIDENTIAL, time)\n\n      byType: (type, time) ->\n        building = undefined\n        switch type\n          when Building.Type.RESIDENTIAL\n            building = new Building({x: 0, y: 0}, 0, 80, Building.Type.RESIDENTIAL, math.randomRange(0.5, 2))\n          when Building.Type.IMPORT\n            building = new Building({x: 0, y: 0}, 0, 150, Building.Type.IMPORT, math.randomRange(0.5, 2))\n        return building\n\n      aroundSegment: (buildingTemplate, segment, count, radius, quadtree) ->\n        buildings = []\n        for i in [0...count] by 1\n          randomAngle = Math.random() * 360\n          randomRadius = Math.random() * radius\n          buildingCenter =\n            x: 0.5 * (segment.r.start.x + segment.r.end.x) + randomRadius * math.sinDegrees(randomAngle)\n            y: 0.5 * (segment.r.start.y + segment.r.end.y) + randomRadius * math.cosDegrees(randomAngle)\n          building = buildingTemplate()\n          building.setCenter(buildingCenter)\n          building.setDir(segment.dir())\n\n          permitBuilding = false\n          for i in [0...config.mapGeneration.BUILDING_PLACEMENT_LOOP_LIMIT] by 1\n            collisionCount = 0\n            # must query quadtree here, since building limits may have changed due to collision in previous iteration\n            potentialCollisions = quadtree.retrieve(building.collider.limits())\n            potentialCollisions = potentialCollisions.concat(buildings)\n            for obj in potentialCollisions\n              # if it is a quadtree result, unpack it\n              if (obj.o?)\n                obj = obj.o\n\n              result = building.collider.collide(obj.collider)\n              if (result)\n                collisionCount += 1\n                # no point continuing if on final loop\n                if (i == config.mapGeneration.BUILDING_PLACEMENT_LOOP_LIMIT - 1)\n                  break\n\n                # shift building to avoid colliding with existing object\n                building.setCenter(math.addPoints(building.center, result))\n\n            # no further checks necessary\n            if (collisionCount == 0)\n              permitBuilding = true\n              break\n\n          if (permitBuilding)\n            buildings.push(building)\n\n        return buildings\n    }\n";

// ---- compile & run ----
(function(global){
  function run(){
    if (!global.CoffeeScript || !global.CoffeeScript.compile) {
      console.error('CoffeeScript runtime not found. Paste the v1.12.7 minified runtime in the placeholder near the top of this file.');
      return;
    }
    try {
      var js = global.CoffeeScript.compile(COFFEE_SRC, {bare:true});
      (0, eval)(js);
      global.CityGenReady = true;
      console.log('CityGen compiled and executed (offline).');
    } catch (e) {
      console.error('Failed to compile/run CoffeeScript:', e);
    }
  }
  // Run synchronously. As a classic script, this will execute before the
  // deferred module script that depends on it, resolving the race condition.
  run();
})(typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : this));
})();