(function(){
// CityGen â€” Single JS (offline-ready placeholder, cleaned & fixed)

// To make this 100% offline with no external requests:
// 1) Download CoffeeScript runtime (v1.12.7) and paste the **minified** code in the placeholder below.
//    Download link: https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.12.7/coffee-script.min.js
//    (Open the URL, copy the minified code, and paste between the markers)
// 2) This file will then compile and run the merged CoffeeScript sources embedded below.

/* ======== BEGIN COFFEESCRIPT RUNTIME (PASTE MINIFIED CODE HERE) ======== */
(function(){var e,n,r,t,o,i,a,u,l,s,c,f,p,m,h,d,g,x,y,S,v={}.hasOwnProperty;if(a=require("fs"),y=require("vm"),h=require("path"),e=require("./lexer").Lexer,m=require("./parser").parser,l=require("./helpers"),n=require("./sourcemap"),p=require("../../package.json"),exports.VERSION=p.version,exports.FILE_EXTENSIONS=[".coffee",".litcoffee",".coffee.md"],exports.helpers=l,r=function(e){switch(!1){case"function"!=typeof Buffer:return new Buffer(e).toString("base64");case"function"!=typeof btoa:return btoa(encodeURIComponent(e).replace(/%([0-9A-F]{2})/g,function(e,n){return String.fromCharCode("0x"+n)}));default:throw new Error("Unable to base64 encode inline sourcemap.")}},S=function(e){return function(n,r){var t;null==r&&(r={});try{return e.call(this,n,r)}catch(e){if(t=e,"string"!=typeof n)throw t;throw l.updateSyntaxError(t,n,r.filename)}}},x={},g={},exports.compile=t=S(function(e,t){var o,i,a,u,s,c,p,h,d,y,S,v,E,N,b,I,T,q,_;if(l.merge,a=l.extend,t=a({},t),p=t.sourceMap||t.inlineMap||null==t.filename,u=t.filename||"<anonymous>",x[u]=e,p&&(E=new n),q=f.tokenize(e,t),t.referencedVars=function(){var e,n,r;for(r=[],e=0,n=q.length;e<n;e++)"IDENTIFIER"===(T=q[e])[0]&&r.push(T[1]);return r}(),null==t.bare||!0!==t.bare)for(h=0,S=q.length;h<S;h++)if(T=q[h],"IMPORT"===(b=T[0])||"EXPORT"===b){t.bare=!0;break}for(c=m.parse(q).compileToFragments(t),i=0,t.header&&(i+=1),t.shiftLine&&(i+=1),o=0,y="",d=0,v=c.length;d<v;d++)s=c[d],p&&(s.locationData&&!/^[;\s]*$/.test(s.code)&&E.add([s.locationData.first_line,s.locationData.first_column],[i,o],{noReplace:!0}),i+=N=l.count(s.code,"\n"),N?o=s.code.length-(s.code.lastIndexOf("\n")+1):o+=s.code.length),y+=s.code;return t.header&&(y="// "+("Generated by CoffeeScript "+this.VERSION)+"\n"+y),p&&(_=E.generate(t,e),g[u]=E),t.inlineMap&&(y=y+"\n"+("//# sourceMappingURL=data:application/json;base64,"+r(JSON.stringify(_)))+"\n"+("//# sourceURL="+(null!=(I=t.filename)?I:"coffeescript"))),t.sourceMap?{js:y,sourceMap:E,v3SourceMap:JSON.stringify(_,null,2)}:y}),exports.tokens=S(function(e,n){return f.tokenize(e,n)}),exports.nodes=S(function(e,n){return"string"==typeof e?m.parse(f.tokenize(e,n)):m.parse(e)}),exports.run=function(e,n){var r,o,i,u;return null==n&&(n={}),i=require.main,i.filename=process.argv[1]=n.filename?a.realpathSync(n.filename):"<anonymous>",i.moduleCache&&(i.moduleCache={}),o=null!=n.filename?h.dirname(a.realpathSync(n.filename)):a.realpathSync("."),i.paths=require("module")._nodeModulePaths(o),l.isCoffee(i.filename)&&!require.extensions||(e=null!=(u=(r=t(e,n)).js)?u:r),i._compile(e,i.filename)},exports.eval=function(e,n){var r,o,i,a,u,l,s,c,f,p,m,d,g,x,S,E,N;if(null==n&&(n={}),e=e.trim()){if(a=null!=(d=y.Script.createContext)?d:y.createContext,l=null!=(g=y.isContext)?g:function(e){return n.sandbox instanceof a().constructor},a){if(null!=n.sandbox){if(l(n.sandbox))E=n.sandbox;else{E=a(),x=n.sandbox;for(c in x)v.call(x,c)&&(N=x[c],E[c]=N)}E.global=E.root=E.GLOBAL=E}else E=global;if(E.__filename=n.filename||"eval",E.__dirname=h.dirname(E.__filename),E===global&&!E.module&&!E.require){for(r=require("module"),E.module=o=new r(n.modulename||"eval"),E.require=i=function(e){return r._load(e,o,!0)},o.filename=E.__filename,u=0,f=(S=Object.getOwnPropertyNames(require)).length;u<f;u++)"paths"!==(m=S[u])&&"arguments"!==m&&"caller"!==m&&(i[m]=require[m]);i.paths=o.paths=r._nodeModulePaths(process.cwd()),i.resolve=function(e){return r._resolveFilename(e,o)}}}p={};for(c in n)v.call(n,c)&&(N=n[c],p[c]=N);return p.bare=!0,s=t(e,p),E===global?y.runInThisContext(s):y.runInContext(s,E)}},exports.register=function(){return require("./register")},require.extensions)for(o=function(e){var n;return null!=(n=require.extensions)[e]?n[e]:n[e]=function(){throw new Error("Use CoffeeScript.register() or require the coffee-script/register module to require "+e+" files.")}},s=0,c=(d=this.FILE_EXTENSIONS).length;s<c;s++)o(d[s]);exports._compileFile=function(e,n,r){var o,i,u,s;null==n&&(n=!1),null==r&&(r=!1),u=a.readFileSync(e,"utf8"),s=65279===u.charCodeAt(0)?u.substring(1):u;try{o=t(s,{filename:e,sourceMap:n,inlineMap:r,sourceFiles:[e],literate:l.isLiterate(e)})}catch(n){throw i=n,l.updateSyntaxError(i,s,e)}return o},f=new e,m.lexer={lex:function(){var e,n;return(n=m.tokens[this.pos++])?(e=n[0],this.yytext=n[1],this.yylloc=n[2],m.errorToken=n.origin||n,this.yylineno=this.yylloc.first_line):e="",e},setInput:function(e){return m.tokens=e,this.pos=0},upcomingInput:function(){return""}},m.yy=require("./nodes"),m.yy.parseError=function(e,n){var r,t,o,i,a;return n.token,i=m.errorToken,a=m.tokens,t=i[0],o=i[1],r=i[2],o=function(){switch(!1){case i!==a[a.length-1]:return"end of input";case"INDENT"!==t&&"OUTDENT"!==t:return"indentation";case"IDENTIFIER"!==t&&"NUMBER"!==t&&"INFINITY"!==t&&"STRING"!==t&&"STRING_START"!==t&&"REGEX"!==t&&"REGEX_START"!==t:return t.replace(/_START$/,"").toLowerCase();default:return l.nameWhitespaceCharacter(o)}}(),l.throwSyntaxError("unexpected "+o,r)},i=function(e,n){var r,t,o,i,a,u,l,s,c,f,p;return i=void 0,o="",e.isNative()?o="native":(e.isEval()?(i=e.getScriptNameOrSourceURL())||(o=e.getEvalOrigin()+", "):i=e.getFileName(),i||(i="<anonymous>"),o=(c=n(i,l=e.getLineNumber(),t=e.getColumnNumber()))?i+":"+c[0]+":"+c[1]:i+":"+l+":"+t),a=e.getFunctionName(),u=e.isConstructor(),!(e.isToplevel()||u)?(s=e.getMethodName(),p=e.getTypeName(),a?(f=r="",p&&a.indexOf(p)&&(f=p+"."),s&&a.indexOf("."+s)!==a.length-s.length-1&&(r=" [as "+s+"]"),""+f+a+r+" ("+o+")"):p+"."+(s||"<anonymous>")+" ("+o+")"):u?"new "+(a||"<anonymous>")+" ("+o+")":a?a+" ("+o+")":o},u=function(e){return null!=g[e]?g[e]:null!=g["<anonymous>"]?g["<anonymous>"]:null!=x[e]?t(x[e],{filename:e,sourceMap:!0,literate:l.isLiterate(e)}).sourceMap:null},Error.prepareStackTrace=function(e,n){var r,t,o;return o=function(e,n,r){var t,o;return null!=(o=u(e))&&(t=o.sourceLocation([n-1,r-1])),null!=t?[t[0]+1,t[1]+1]:null},t=function(){var e,t,a;for(a=[],e=0,t=n.length;e<t&&(r=n[e]).getFunction()!==exports.run;e++)a.push("    at "+i(r,o));return a}(),e.toString()+"\n"+t.join("\n")+"\n"}}).call(this);
/* ========  END  COFFEESCRIPT RUNTIME (PASTE MINIFIED CODE HERE)  ======== */

// ---- math.js exposed as generic_modules/math ----
(function(global){
  var module = {exports: {}};
  var exports = module.exports;
var Epsilon = 0.00000001;

module.exports = {
  /**
   * @author Peter Kelley
   * @author pgkelley4@gmail.com
   */

  /**
   * See if two line segments intersect. This uses the
   * vector cross product approach described below:
   * http://stackoverflow.com/a/565282/786339
   *
   * @param {Object} p point object with x and y coordinates
   *  representing the start of the 1st line.
   * @param {Object} p2 point object with x and y coordinates
   *  representing the end of the 1st line.
   * @param {Object} q point object with x and y coordinates
   *  representing the start of the 2nd line.
   * @param {Object} q2 point object with x and y coordinates
   *  representing the end of the 2nd line.
   */
  doLineSegmentsIntersect: function (p, p2, q, q2, omitEnds) {
    var r = this.subtractPoints(p2, p);
    var s = this.subtractPoints(q2, q);

    var uNumerator = this.crossProduct(this.subtractPoints(q, p), r);
    var denominator = this.crossProduct(r, s);

    if (uNumerator == 0 && denominator == 0) {
      return false;
      // colinear, so do they overlap?
      // return ((q.x - p.x < 0) != (q.x - p2.x < 0) != (q2.x - p.x < 0) != (q2.x - p2.x < 0)) ||
      //   ((q.y - p.y < 0) != (q.y - p2.y < 0) != (q2.y - p.y < 0) != (q2.y - p2.y < 0));
    }

    if (denominator == 0) {
      // lines are paralell
      return false;
    }

    var u = uNumerator / denominator;
    var t = this.crossProduct(this.subtractPoints(q, p), s) / denominator;

    var doSegmentsIntersect;
    if (!omitEnds) {
      doSegmentsIntersect = (t >= 0) && (t <= 1) && (u >= 0) && (u <= 1);
    } else {
       doSegmentsIntersect = (t > 0.001) && (t < 1-0.001) && (u > 0.001) && (u < 1-0.001);
    }

    if (doSegmentsIntersect) {
      return { x: p.x + t * r.x, y: p.y + t * r.y, t: t }
    }

    return doSegmentsIntersect;
  },

  equalV: function(v1, v2) {
    var diff = this.subtractPoints(v1, v2);
    var length2 = this.lengthV2(diff);
    return length2 < Epsilon;
  },

  addPoints: function(point1, point2) {
    var result = {};
    result.x = point1.x + point2.x;
    result.y = point1.y + point2.y;

    return result;
  },

  subtractPoints: function (point1, point2) {
    return {
      x: point1.x - point2.x,
      y: point1.y - point2.y
    }
  },

  crossProduct: function (point1, point2) {
    return point1.x * point2.y - point1.y * point2.x;
  },

  dotProduct: function(point1, point2) {
    return point1.x * point2.x + point1.y * point2.y;
  },

  length: function (point1, point2) {
    var v = this.subtractPoints(point2, point1);
    return this.lengthV(v);
  },

  length2: function (point1, point2) {
    var v = this.subtractPoints(point2, point1);
    return this.lengthV2(v);
  },

  lengthV: function(v) {
    return Math.sqrt(this.lengthV2(v));
  },

  lengthV2: function(v) {
    return v.x * v.x + v.y * v.y;
  },

  angleBetween: function(v1, v2) {
    var angleRad = Math.acos( (v1.x * v2.x + v1.y * v2.y) /
      ( this.lengthV(v1) * this.lengthV(v2) ) );
    var angleDeg = angleRad * 180 / Math.PI;
    return angleDeg;
  },

  sign: function(x) {
    if (x > 0) {
      return 1;
    } else if (x < 0) {
      return -1;
    } else {
      return 0;
    }
  },

  fractionBetween: function (v1, v2, fraction) {
    var v1ToV2 = this.subtractPoints(v2, v1);
    return {x: (v1.x + v1ToV2.x * fraction), y: (v1.y + v1ToV2.y * fraction)}
  },

  sinDegrees: function(deg) {
    return Math.sin(deg * Math.PI / 180);
  },

  cosDegrees: function(deg) {
    return Math.cos(deg * Math.PI / 180);
  },

  atanDegrees: function(val) {
    return Math.atan(val) * 180 / Math.PI;
  },

  randomRange: function(min, max) {
    return Math.random()*(max - min) + min;
  },

  multVScalar: function(v, n) {
    return {x: v.x * n, y: v.y * n};
  },

  divVScalar: function(v, n) {
    return {x: v.x / n, y: v.y / n};
  },

  oldDistanceToLine: function(p, q1, q2) {
    // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
    var qV = this.subtractPoints(q2, q1);
    var length = this.lengthV(qV);
    var qVNorm = this.divVScalar(qV, length);

    var eq2 = this.dotProduct(this.subtractPoints(q1, p), qVNorm);
    var qVNormMult = this.multVScalar(qVNorm, eq2);
    var vToLine = this.subtractPoints(this.subtractPoints(q1, p), qVNormMult);

    return {
      distance: this.lengthV(vToLine),
      pointOnLine: this.addPoints(p, vToLine),
      // distance along line of projected point
      lineProj: -eq2,
      length: length
    };
  },

  newDistanceToLine: function(P, A, B) {
    var AP = this.subtractPoints(P, A);
    var AB = this.subtractPoints(B, A);
    var result = this.project(AP, AB);
    var AD = result.projected;
    var D = this.addPoints(A, AD);

    return {
      distance: this.length(D, P),
      pointOnLine: D,
      // distance along line of projected point
      lineProj: this.sign(result.dotProduct) * this.lengthV(AD) ,
      length: this.lengthV(AB)
    };
  },

  distanceToLine: function(P, A, B) {
    var AP = this.subtractPoints(P, A);
    var AB = this.subtractPoints(B, A);
    var result = this.project(AP, AB);
    var AD = result.projected;
    var D = this.addPoints(A, AD);

    return {
      distance2: this.length2(D, P),
      pointOnLine: D,
      // distance along line of projected point
      lineProj2: this.sign(result.dotProduct) * this.lengthV2(AD) ,
      length2: this.lengthV2(AB)
    };
  },

  project: function(v, onto) {
    // http://en.wikipedia.org/wiki/Vector_projection
    var dotProduct = this.dotProduct(v, onto);
    return {
      dotProduct: dotProduct,
      projected: this.multVScalar(onto, dotProduct / this.lengthV2(onto))
    }
  }
};


  // Register as CommonJS-like module for our in-bundle require shim
  global.__CityGenModules__ = global.__CityGenModules__ || {};
  global.__CityGenModules__['generic_modules/math'] = module.exports;
})(typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : this));

// ---- improved require shim + built-in stubs for offline ----
(function(global){
  var REG = global.__CityGenModules__ = global.__CityGenModules__ || {};

  // Minimal lodash we need
  function lodashFactory(){
    function isArray(a){ return Array.isArray(a); }
    function each(coll, iter){
      if (!coll) return;
      if (isArray(coll)) { for (var i=0;i<coll.length;i++) iter(coll[i], i); }
      else { for (var k in coll) if (Object.prototype.hasOwnProperty.call(coll,k)) iter(coll[k], k); }
    }
    function findIndex(arr, pred){
      for (var i=0;i<arr.length;i++){ if (pred(arr[i], i)) return i; }
      return -1;
    }
    function getter(iter){
      if (typeof iter === 'function') return iter;
      if (typeof iter === 'string') return function(o){ return o && o[iter]; };
      return function(x){ return x; };
    }
    function minBy(arr, iter){
      if (!arr || !arr.length) return undefined;
      var g = getter(iter), min = arr[0], minv = g(min);
      for (var i=1;i<arr.length;i++){ var v=g(arr[i]); if (v < minv){ minv=v; min=arr[i]; } }
      return min;
    }
    function maxBy(arr, iter){
      if (!arr || !arr.length) return undefined;
      var g = getter(iter), max = arr[0], maxv = g(max);
      for (var i=1;i<arr.length;i++){ var v=g(arr[i]); if (v > maxv){ maxv=v; max=arr[i]; } }
      return max;
    }
    function min(arr, iter){ return iter ? minBy(arr, iter) : Math.min.apply(null, arr); }
    function max(arr, iter){ return iter ? maxBy(arr, iter) : Math.max.apply(null, arr); }
    function assign(target){
      for (var i=1;i<arguments.length;i++){
        var src = arguments[i]; if (!src) continue;
        for (var k in src){ if (Object.prototype.hasOwnProperty.call(src,k)) target[k] = src[k]; }
      }
      return target;
    }
    function some(arr, pred){
      for (var i=0;i<arr.length;i++){ if (pred(arr[i], i)) return true; }
      return false;
    }
    function partialRight(fn){
      var rightArgs = Array.prototype.slice.call(arguments,1);
      return function(){
        var args = Array.prototype.slice.call(arguments);
        return fn.apply(this, args.concat(rightArgs));
      };
    }
    function clone(x){ return Array.isArray(x) ? x.slice() : assign({}, x); }
    function cloneDeep(x){ return JSON.parse(JSON.stringify(x)); }

    return {
      cloneDeep: cloneDeep,
      clone: clone,
      assign: assign,
      each: each,
      findIndex: findIndex,
      min: min,
      max: max,
      partialRight: partialRight,
      some: some,
      any: some // alias
    };
  }

  // Simple Quadtree stub (AABB filter)
  function Quadtree(bounds, maxObjects, maxLevels){
    this._bounds = bounds || {x:-1e9,y:-1e9,width:2e9,height:2e9};
    this._items = [];
  }
  Quadtree.prototype.insert = function(entry){ this._items.push(entry); };
  function overlaps(a,b){
    return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
  }
  Quadtree.prototype.retrieve = function(area){
    var out = [];
    for (var i=0;i<this._items.length;i++){
      var it = this._items[i];
      if (!area || overlaps(area, it)) out.push(it);
    }
    return out;
  };

  // Tiny seedrandom replacement
  (function(){
    function makeLCG(seed){
      var s = 0;
      // string seed hash
      var str = String(seed);
      for (var i=0;i<str.length;i++){ s = (s*31 + str.charCodeAt(i))|0; }
      var state = (s>>>0) + 1;
      return function(){
        state = (state * 1664525 + 1013904223) >>> 0;
        return state / 4294967296;
      };
    }
    Math.seedrandom = function(seed){
      var rnd = makeLCG(seed);
      Math.random = rnd;
      return rnd;
    };
  })();

  // Perlin-like stub with seed
  var perlin = (function(){
    var _seed = 0;
    return {
      seed: function(s){ _seed = +s || 0; },
      simplex2: function(x,y){
        var n = Math.sin(x*12.9898 + y*78.233 + _seed*43758.5453);
        var f = n - Math.floor(n);
        return f*2 - 1; // [-1,1]
      }
    };
  })();

  // Simple HashMap wrapper to match .put/.get API
  function HashMap(){
    this._m = new Map();
  }
  HashMap.prototype.put = function(k,v){ this._m.set(k,v); };
  HashMap.prototype.get = function(k){ return this._m.get(k); };
  HashMap.prototype.has = function(k){ return this._m.has(k); };

  // Expose stubs to global for optional external overrides
  global.Quadtree = { Quadtree: Quadtree };
  global.perlin = perlin;
  global.seedrandom = Math.seedrandom; // for require convenience

  // Provide a very small 'PIXI' stub (not used by core logic here)
  global.PIXI = global.PIXI || {};

  // The require shim
  global.require = function(name){
    if (REG[name]) return REG[name];
    // Known aliases used by the original project
    if (name === 'lodash' || name === '_') return global._ || (REG[name] = lodashFactory());
    if (name === 'pixi.js/bin/pixi.js') return global.PIXI || (function(){ throw new Error('PIXI not provided'); })();
    if (name === 'perlin') return global.perlin || (function(){ throw new Error('perlin noise not provided'); })();
    if (name === 'quadtree') return global.Quadtree || (function(){ throw new Error('Quadtree not provided'); })();
    if (name === 'seedrandom') return global.seedrandom || (function(){ throw new Error('seedrandom not provided'); })();
    if (name === 'map') return REG[name] || (REG[name] = HashMap);
    if (name.indexOf('generic_modules/') === 0) throw new Error('Module '+name+' not registered');
    if (name.indexOf('game_modules/') === 0) throw new Error('Module '+name+' not registered');
    throw new Error('Unknown module '+name);
  };
})(typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : this));

// ---- merged CoffeeScript sources (patched to self-register modules) ----
var COFFEE_SRC = "### BEGIN FILE: config.coffee\n\n\n# author: tmwhere.com\n\nmath = require('generic_modules/math')\n\nbranchAngleDev = 3\nforwardAngleDev = 15\nrandomAngle = (limit) ->\n  # non-linear distribution\n  nonUniformNorm = Math.pow(Math.abs(limit), 3)\n  val = 0\n  while (val == 0 || Math.random() < Math.pow(Math.abs(val), 3)/nonUniformNorm)\n    val = math.randomRange(-limit, +limit)\n  return val\n\nconfigVariables = {\n  mapGeneration:\n    BUILDING_PLACEMENT_LOOP_LIMIT: 3 # by the nth iteration of building placement no further collisions are allowed\n    DEFAULT_SEGMENT_LENGTH: 300\n    HIGHWAY_SEGMENT_LENGTH: 400\n    DEFAULT_SEGMENT_WIDTH: 6\n    HIGHWAY_SEGMENT_WIDTH: 16\n    RANDOM_BRANCH_ANGLE: ->\n      randomAngle(branchAngleDev)\n    RANDOM_STRAIGHT_ANGLE: ->\n      randomAngle(forwardAngleDev)\n    DEFAULT_BRANCH_PROBABILITY: 0.4\n    HIGHWAY_BRANCH_PROBABILITY: 0.05\n    HIGHWAY_BRANCH_POPULATION_THRESHOLD: 0.1\n    NORMAL_BRANCH_POPULATION_THRESHOLD: 0.1\n    NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY: 5\n    MINIMUM_INTERSECTION_DEVIATION: 30 # degrees\n    SEGMENT_COUNT_LIMIT: 2000\n    DEBUG_DELAY: 0 # ms\n    ROAD_SNAP_DISTANCE: 50\n    HEAT_MAP_PIXEL_DIM: 50 # px\n    DRAW_HEATMAP: false\n    QUADTREE_PARAMS:\n      x: -20000\n      y: -20000\n      width: 40000\n      height: 40000\n    QUADTREE_MAX_OBJECTS: 10\n    QUADTREE_MAX_LEVELS: 10\n    DEBUG: false\n  gameLogic:\n    SELECT_PAN_THRESHOLD: 50 # px, limit beyond which a click becomes a drag\n    SELECTION_RANGE: 50 # px\n    DEFAULT_PICKUP_RANGE: 150 # world units\n    DEFAULT_CARGO_CAPACITY: 1\n    MIN_SPEED_PROPORTION: 0.1 # the minimum reduction of the speed of a road when congested\n}\n\n# register module (instead of module.exports)\nroot = if typeof window isnt 'undefined' then window else if typeof self isnt 'undefined' then self else this\nroot.__CityGenModules__ ?= {}\nroot.__CityGenModules__['game_modules/config'] = do ->\n  return configVariables\n\n\n### BEGIN FILE: utility.coffee\n\n\n_ = require('lodash')\n\n# register module\nroot = if typeof window isnt 'undefined' then window else if typeof self isnt 'undefined' then self else this\nroot.__CityGenModules__ ?= {}\nroot.__CityGenModules__['generic_modules/utility'] =\n  defaultFor: (arg, val, deep) ->\n    argCopy = if deep then _.cloneDeep(arg) else arg\n    valCopy = if deep then _.cloneDeep(val) else val\n    if typeof arg != 'undefined' then argCopy else valCopy\n\n  joinArrayGeneric: (array, joinElement) ->\n    copy = array.slice(0)\n    for i in [1...copy.length * 2 - 1] by 2\n      copy.splice(i, 0, joinElement)\n    return copy\n    \n\n  addArrayPushListener: (array, callback) ->\n    array.push = ->\n      for i in [0..arguments.length-1] by 1\n          this[@length] = arguments[i]\n          callback()\n      return this.length\n\n  minDegreeDifference: (d1, d2) ->\n    diff = Math.abs(d1 - d2) % 180\n    return Math.min(diff, Math.abs(diff-180))\n\n  extendedMin: (collection, selector) ->\n    if (!selector?)\n      selector = (obj) -> obj\n\n    minObj = undefined\n    minObj_i = 0\n    _.each(collection, (obj, i) ->\n      if (!minObj? || selector(obj) < selector(minObj)) \n        minObj = obj\n        minObj_i = i\n    )\n    return [minObj, minObj_i]\n\n  extendedMax: (collection, selector) ->\n    if (!selector?)\n      selector = (obj) -> obj\n\n    maxObj = undefined\n    maxObj_i = 0\n    _.each(collection, (obj, i) ->\n      if (!maxObj? || selector(obj) > selector(maxObj)) \n        maxObj = obj\n        maxObj_i = i\n    )\n    return [maxObj, maxObj_i]\n\n  PriorityQueue:\n    class PriorityQueue\n      constructor: ->\n        @list = []\n\n      put: (item, priority) ->\n        newPair =\n          item: item\n          priority: priority\n\n        index = _.findIndex(@list, (pair) ->\n          pair.priority > newPair.priority\n        )\n        if (index == - 1)\n          @list.push(newPair)\n        else\n          @list.splice(index, 0, newPair)\n        \n      get: ->\n        @list.shift().item\n\n      length: ->\n        @list.length\n\n### BEGIN FILE: collision.coffee\n\n\n# author: tmwhere.com\n\n_ = require('lodash')\n\nmath = require('generic_modules/math')\nutil = require('generic_modules/utility')\n\n# register module\nroot = if typeof window isnt 'undefined' then window else if typeof self isnt 'undefined' then self else this\nroot.__CityGenModules__ ?= {}\nroot.__CityGenModules__['generic_modules/collision'] =\n  CollisionObject:\n    class CollisionObject\n      @Type:\n        RECT: \"rect\"\n        LINE: \"line\"\n        CIRCLE: \"circle\"\n\n      constructor: (@o, @collisionType, @collisionProperties) ->\n        @collisionRevision = 0\n        @limitsRevision = undefined\n\n        @cachedLimits = undefined\n\n      updateCollisionProperties: (props) ->\n        @collisionRevision++\n        @collisionProperties = _.assign(@collisionProperties, props)\n\n      limits: ->\n        if (@collisionRevision != @limitsRevision)\n          @limitsRevision = @collisionRevision\n          @cachedLimits = switch @collisionType\n            when CollisionObject.Type.RECT\n              minX = _.min(@collisionProperties.corners, 'x').x\n              minY = _.min(@collisionProperties.corners, 'y').y\n              @cachedLimits =\n                x: minX\n                y: minY\n                width: _.max(@collisionProperties.corners, 'x').x - minX\n                height: _.max(@collisionProperties.corners, 'y').y - minY\n                o: @o\n            when CollisionObject.Type.LINE\n              x: Math.min(@collisionProperties.start.x, @collisionProperties.end.x)\n              y: Math.min(@collisionProperties.start.y, @collisionProperties.end.y)\n              width: Math.abs(@collisionProperties.start.x - @collisionProperties.end.x)\n              height: Math.abs(@collisionProperties.start.y - @collisionProperties.end.y)\n              o: @o\n            when CollisionObject.Type.CIRCLE\n              x: @collisionProperties.center.x - @collisionProperties.radius\n              y: @collisionProperties.center.y - @collisionProperties.radius\n              width: @collisionProperties.radius * 2\n              height: @collisionProperties.radius * 2\n              o: @o\n\n        return @cachedLimits\n\n      collide: (other) ->\n        # avoid expensive collision check if possible\n        objLimits = @limits()\n        otherLimits = other.limits()\n        if (objLimits? && otherLimits? &&\n        (objLimits.x + objLimits.width < otherLimits.x || otherLimits.x + otherLimits.width < objLimits.x) &&\n        (objLimits.y + objLimits.height < otherLimits.y || otherLimits.y + otherLimits.height < objLimits.y))\n          return false\n\n        switch @collisionType\n          when CollisionObject.Type.CIRCLE\n            switch other.collisionType\n              when CollisionObject.Type.RECT\n                @rectCircleCollision(other.collisionProperties, @collisionProperties)\n          when CollisionObject.Type.RECT\n            switch other.collisionType\n              when CollisionObject.Type.RECT\n                @rectRectIntersection(@collisionProperties, other.collisionProperties)\n              when CollisionObject.Type.LINE\n                @rectRectIntersection(@collisionProperties, @rectPropsFromLine(other.collisionProperties))\n              when CollisionObject.Type.CIRCLE\n                @rectCircleCollision(@collisionProperties, other.collisionProperties)\n          when CollisionObject.Type.LINE\n            switch other.collisionType\n              when CollisionObject.Type.RECT\n                @rectRectIntersection(@rectPropsFromLine(@collisionProperties), other.collisionProperties)\n              when CollisionObject.Type.LINE\n                @rectRectIntersection(@rectPropsFromLine(@collisionProperties), @rectPropsFromLine(other.collisionProperties))\n\n      rectCircleCollision: (rectProps, circleProps) ->\n        corners = rectProps.corners\n\n        # check for corner intersections with circle\n        for i in [0...corners.length] by 1\n          if (math.length2(corners[i], circleProps.center) <= circleProps.radius * circleProps.radius)\n            return true\n\n        # check for edge intersections with circle\n        # from http://stackoverflow.com/a/1079478\n        for i in [0...corners.length] by 1\n          start = corners[i]\n          end = corners[(i + 1) % corners.length]\n          {distance2, lineProj2, length2} = math.distanceToLine(circleProps.center, start, end)\n          if (lineProj2 > 0 && lineProj2 < length2 && distance2 <= circleProps.radius * circleProps.radius)\n            return true\n\n        # check that circle is not enclosed by rectangle\n        axes = [\n          math.subtractPoints(corners[3], corners[0])\n          math.subtractPoints(corners[3], corners[2])\n        ]\n\n        projections = [\n          math.project(math.subtractPoints(circleProps.center, corners[0]), axes[0])\n          math.project(math.subtractPoints(circleProps.center, corners[2]), axes[1])\n        ]\n\n        if (projections[0].dotProduct < 0 || math.lengthV2(projections[0].projected) > math.lengthV2(axes[0]) ||\n        projections[1].dotProduct < 0 || math.lengthV2(projections[1].projected) > math.lengthV2(axes[1]))\n          return false\n\n        return true\n\n      rectPropsFromLine: (lineProps) ->\n        dir = math.subtractPoints(lineProps.end, lineProps.start)\n        perpDir = {x: -dir.y, y: dir.x}\n        halfWidthPerpDir = math.multVScalar(perpDir, 0.5 * lineProps.width / math.lengthV(perpDir))\n        tempRectProps =\n          corners: [\n            math.addPoints(lineProps.start, halfWidthPerpDir),\n            math.subtractPoints(lineProps.start, halfWidthPerpDir),\n            math.subtractPoints(lineProps.end, halfWidthPerpDir),\n            math.addPoints(lineProps.end, halfWidthPerpDir)\n          ]\n\n      rectRectIntersection: (rectAProps, rectBProps) ->\n\n        cA = rectAProps.corners\n        cB = rectBProps.corners\n        # generate axes\n        axes = [\n          math.subtractPoints(cA[3], cA[0]),\n          math.subtractPoints(cA[3], cA[2]),\n          math.subtractPoints(cB[0], cB[1]),\n          math.subtractPoints(cB[0], cB[3])\n        ]\n\n        # list used to find axis with the minimum overlap\n        # that axis is used as the response translation vector\n        axisOverlaps = []\n\n        for axis in axes\n          # project rectangle points to axis\n          projectedVectorsA = []\n          projectedVectorsB = []\n\n          for corner in cA\n            projectedVectorsA.push(math.project(corner, axis).projected)\n          for corner in cB\n            projectedVectorsB.push(math.project(corner, axis).projected)\n\n          # calculate relative positions of rectangles on axis\n          positionsOnAxisA = []\n          positionsOnAxisB = []\n\n          for v in projectedVectorsA\n            positionsOnAxisA.push(math.dotProduct(v, axis))\n          for v in projectedVectorsB\n            positionsOnAxisB.push(math.dotProduct(v, axis))\n\n          [maxA, maxA_i] = util.extendedMax(positionsOnAxisA)\n          [minA, minA_i] = util.extendedMin(positionsOnAxisA)\n          [maxB, maxB_i] = util.extendedMax(positionsOnAxisB)\n          [minB, minB_i] = util.extendedMin(positionsOnAxisB)\n          # if the rectangles don't overlap on at least one axis\n          # they are not colliding\n          if (maxA < minB || maxB < minA)\n            return false\n          else\n            # calculate the overlap between the rectangles on this axis\n            diff1 = math.subtractPoints(projectedVectorsA[maxA_i], projectedVectorsB[minB_i])\n            diff2 = math.subtractPoints(projectedVectorsB[maxB_i], projectedVectorsA[minA_i])\n\n            if (math.lengthV2(diff1) < math.lengthV2(diff2))\n              axisOverlaps.push(diff1)\n            else\n              # the rectangles overlap on the other side\n              # invert the vector so that it will push out of the collision\n              axisOverlaps.push(math.multVScalar(diff2, -1))\n\n        # find axis with the minimum overlap\n        minVector = _.min(axisOverlaps, (v) ->\n          math.lengthV2(v)\n        )\n\n        # return displacement required to pull rectA from collision\n        return math.multVScalar(minVector, -1)\n\n\n### BEGIN FILE: astar.coffee\n\n\n# author: tmwhere.com\n\nutil = require('generic_modules/utility')\nHashMap = require('map')\n\n# register module\nroot = if typeof window isnt 'undefined' then window else if typeof self isnt 'undefined' then self else this\nroot.__CityGenModules__ ?= {}\nroot.__CityGenModules__['generic_modules/astar'] =\n  PathLocation:\n    class PathLocation\n      constructor: (@o, @fraction) ->\n\n  calc: do ->\n    cost = (current, next, start, end) ->\n      currentFraction = undefined\n      nextFraction = undefined\n      if (start.o == end.o)\n        fraction = Math.abs(start.fraction - end.fraction)\n        return fraction * current.cost()\n      else\n        if (current == start.o)\n          currentFraction = start.fraction\n        if (next == end.o)\n          nextFraction = end.fraction\n      return current.costTo(next, currentFraction) + next.costTo(current, nextFraction)\n\n    {\n      find: (start, end) ->\n        frontier = new util.PriorityQueue\n        frontier.put(start.o, 0)\n        came_from = new HashMap\n        came_from.put(start.o, null)\n        cost_so_far = new HashMap\n        cost_so_far.put(start.o, 0)\n\n        while (frontier.length() > 0)\n          current = frontier.get()\n\n          if current == end.o\n            break\n\n          for next in current.neighbours()\n            new_cost = cost_so_far.get(current) + cost(current, next, start, end)\n            if !cost_so_far.get(next)? || new_cost < cost_so_far.get(next)\n              cost_so_far.put(next, new_cost)\n              priority = new_cost # + heuristic(goal, next)\n              frontier.put(next, priority)\n              came_from.put(next, current)\n\n        console.log(\"path cost: #{cost_so_far.get(end.o)}\")\n        # reconstruct path\n        current = end.o\n        path = [current]\n        while current != start.o\n          current = came_from.get(current)\n          path.unshift(current)\n\n        return path\n    }\n\n\n### BEGIN FILE: mapgen.coffee\n\n\n# author: tmwhere.com\n\nPIXI = require('pixi.js/bin/pixi.js')\n_ = require('lodash')\n\nnoise = require('perlin').noise\nQuadtree = require('quadtree').Quadtree\nseedrandom = require('seedrandom')\n\nmath = require('generic_modules/math')\nutil = require('generic_modules/utility')\ncollision = require('generic_modules/collision')\n\nconfig = require('game_modules/config')\n\nclass Segment extends collision.CollisionObject\n  @End:\n    START: \"start\"\n    END: \"end\"\n\n  constructor: (start, end, t, q) ->\n    obj = @\n\n    start = _.cloneDeep(start)\n    end = _.cloneDeep(end)\n    t = util.defaultFor(t, 0)\n    q = util.defaultFor(q, {}, true)\n\n    @width = if q.highway then config.mapGeneration.HIGHWAY_SEGMENT_WIDTH else config.mapGeneration.DEFAULT_SEGMENT_WIDTH\n    @collider = new collision.CollisionObject(this, collision.CollisionObject.Type.LINE, {start: start, end: end, width: @width})\n\n    @roadRevision = 0\n    @dirRevision = undefined\n    @lengthRevision = undefined\n\n    @cachedDir = undefined\n    @cachedLength = undefined\n\n    # representation of road\n    @r =\n      start: start\n      end: end\n      setStart: (val) ->\n        @start = val\n        obj.collider.updateCollisionProperties({start: @start})\n        obj.roadRevision++\n      setEnd: (val) ->\n        @end = val\n        obj.collider.updateCollisionProperties({end: @end})\n        obj.roadRevision++\n\n    # time-step delay before this road is evaluated\n    @t = t\n    # meta-information relevant to global goals\n    @q = q\n    # links backwards and forwards\n    @links =\n      b: []\n      f: []\n\n    @users = []\n    [@maxSpeed, @capacity] =\n      if (q.highway)\n        [1200, 12]\n      else\n        [800, 6]\n\n  currentSpeed: ->\n    # subtract 1 from users length so that a single user can go full speed\n    Math.min(config.gameLogic.MIN_SPEED_PROPORTION, 1 - Math.max(0, @users.length - 1) / @capacity) * @maxSpeed\n\n  # clockwise direction\n  dir: ->\n    if (@dirRevision != @roadRevision)\n      @dirRevision = @roadRevision\n      vector = math.subtractPoints(@r.end, @r.start)\n      @cachedDir = -1 * math.sign(math.crossProduct({x:0, y: 1}, vector)) * math.angleBetween({x: 0, y: 1}, vector)\n    return @cachedDir\n\n  length: ->\n    if (@lengthRevision != @roadRevision)\n      @lengthRevision = @roadRevision\n      @cachedLength = math.length(@r.start, @r.end)\n    return @cachedLength\n\n  debugLinks: ->\n    @q.color = 0x00FF00\n    _.each(@links.b, (backwards) ->\n      backwards.q.color = 0xFF0000\n    )\n    _.each(@links.f, (forwards) ->\n      forwards.q.color = 0x0000FF\n    )\n\n  startIsBackwards: ->\n    if (@links.b.length > 0)\n      math.equalV(@links.b[0].r.start, @r.start) ||\n      math.equalV(@links.b[0].r.end, @r.start)\n    else\n      math.equalV(@links.f[0].r.start, @r.end) ||\n      math.equalV(@links.f[0].r.end, @r.end)\n\n  cost: ->\n    @length() / @currentSpeed()\n\n  costTo: (other, fromFraction) ->\n    segmentEnd = @endContaining(other)\n    return @cost() *\n      if fromFraction?\n        switch segmentEnd\n          when Segment.End.START then fromFraction\n          when Segment.End.END then (1-fromFraction)\n      else\n        0.5\n\n  neighbours: ->\n    @links.f.concat(@links.b)\n\n  endContaining: (segment) ->\n    startBackwards = @startIsBackwards()\n    if @links.b.indexOf(segment) != -1\n      return if startBackwards then Segment.End.START else Segment.End.END\n    else if @links.f.indexOf(segment) != -1\n      return if startBackwards then Segment.End.END else Segment.End.START\n    else\n      undefined\n\n  linksForEndContaining: (segment) ->\n    if @links.b.indexOf(segment) != -1\n      @links.b\n    else if @links.f.indexOf(segment) != -1\n      @links.f\n    else\n      undefined\n\n  split: (point, segment, segmentList, qTree) ->\n    startIsBackwards = @startIsBackwards()\n\n    splitPart = segmentFactory.fromExisting(this)\n    addSegment(splitPart, segmentList, qTree)\n    splitPart.r.setEnd(point)\n    @r.setStart(point)\n\n    # links are not copied using the preceding factory method\n    # copy link array for the split part, keeping references the same\n    splitPart.links.b = @links.b.slice(0)\n    splitPart.links.f = @links.f.slice(0)\n\n    # work out which links correspond to which end of the split segment\n    if (startIsBackwards)\n      firstSplit = splitPart\n      secondSplit = this\n      fixLinks = splitPart.links.b\n    else\n      firstSplit = this\n      secondSplit = splitPart\n      fixLinks = splitPart.links.f\n\n    _.each(fixLinks, (link) ->\n      index = link.links.b.indexOf(this)\n      if (index != -1)\n        link.links.b[index] = splitPart\n      else\n        index = link.links.f.indexOf(this)\n        link.links.f[index] = splitPart\n    , this)\n    firstSplit.links.f = []\n    firstSplit.links.f.push(segment)\n    firstSplit.links.f.push(secondSplit)\n\n    secondSplit.links.b = []\n    secondSplit.links.b.push(segment)\n    secondSplit.links.b.push(firstSplit)\n\n    segment.links.f.push(firstSplit)\n    segment.links.f.push(secondSplit)\n\nsegmentFactory = do ->\n  return {\n    fromExisting: (segment, t, r, q) ->\n      t = util.defaultFor(t, segment.t)\n      r = util.defaultFor(r, segment.r)\n      q = util.defaultFor(q, segment.q)\n\n      return new Segment(r.start, r.end, t, q)\n    ,\n    usingDirection: (start, dir, length, t, q) ->\n      # default to east\n      dir = util.defaultFor(dir, 90)\n      length = util.defaultFor(length, config.mapGeneration.DEFAULT_SEGMENT_LENGTH)\n\n      end =\n        x: start.x + length*math.sinDegrees(dir),\n        y: start.y + length*math.cosDegrees(dir)\n      return new Segment(start, end, t, q)\n  }\n\nheatmap = do ->\n  {\n    popOnRoad: (r) ->\n      (@populationAt(r.start.x, r.start.y) + @populationAt(r.end.x, r.end.y))/2\n    populationAt: (x, y) ->\n      value1 = (noise.simplex2(x/10000, y/10000) + 1) / 2\n      value2 = (noise.simplex2(x/20000 + 500, y/20000 + 500) + 1) / 2\n      value3 = (noise.simplex2(x/20000 + 1000, y/20000 + 1000) + 1) / 2\n      Math.pow((value1 * value2 + value3) / 2, 2)\n  }\n\ndoRoadSegmentsIntersect = (r1, r2) ->\n  math.doLineSegmentsIntersect(r1.start, r1.end, r2.start, r2.end, true)\n\nlocalConstraints = (segment, segments, qTree, debugData) ->\n  action =\n    priority: 0,\n    func: undefined,\n    q: {}\n\n  matches = qTree.retrieve(segment.collider.limits())\n  for i in [0..matches.length-1] by 1\n    other = matches[i].o\n\n    # intersection check\n    if (action.priority <= 4)\n      intersection = doRoadSegmentsIntersect(segment.r, other.r)\n      if (intersection)\n        if (!action.q.t? || intersection.t < action.q.t)\n          action.q.t = intersection.t\n\n          do (other, intersection) ->\n            action.priority = 4\n            action.func = ->\n              # if intersecting lines are too similar don't continue\n              if util.minDegreeDifference(other.dir(), segment.dir()) < config.mapGeneration.MINIMUM_INTERSECTION_DEVIATION\n                return false\n\n              other.split(intersection, segment, segments, qTree)\n              segment.r.end = intersection\n              segment.q.severed = true\n\n              if (debugData?)\n                if (!debugData.intersections?)\n                  debugData.intersections = []\n                debugData.intersections.push(\n                  x: intersection.x\n                  y: intersection.y\n                )\n\n              return true\n\n    # snap to crossing within radius check\n    if (action.priority <= 3)\n      # current segment's start must have been checked to have been created.\n      # other segment's start must have a corresponding end.\n      if (math.length(segment.r.end, other.r.end) <= config.mapGeneration.ROAD_SNAP_DISTANCE)\n\n        do (other) ->\n          point = other.r.end\n          action.priority = 3\n          action.func = ->\n            segment.r.end = point\n            segment.q.severed = true\n\n            # update links of otherSegment corresponding to other.r.end\n            links = if other.startIsBackwards() then other.links.f else other.links.b\n            # check for duplicate lines, don't add if it exists\n            # this should be done before links are setup, to avoid having to undo that step\n            if _.any(links, (link) ->\n              ((math.equalV(link.r.start, segment.r.end) && math.equalV(link.r.end, segment.r.start)) ||\n              (math.equalV(link.r.start, segment.r.start) && math.equalV(link.r.end, segment.r.end))))\n              return false\n\n            _.each(links, (link) ->\n              # pick links of remaining segments at junction corresponding to other.r.end\n              link.linksForEndContaining(other).push(segment)\n\n              # add junction segments to snapped segment\n              segment.links.f.push(link)\n            )\n\n            links.push(segment)\n            segment.links.f.push(other)\n\n            if (debugData?)\n              if (!debugData.snaps?)\n                debugData.snaps = []\n              debugData.snaps.push(\n                x: point.x\n                y: point.y\n              )\n\n            return true\n\n    # intersection within radius check\n    if (action.priority <= 2)\n\n      {distance2, pointOnLine, lineProj2, length2} = math.distanceToLine(segment.r.end, other.r.start, other.r.end)\n      if (distance2 < config.mapGeneration.ROAD_SNAP_DISTANCE * config.mapGeneration.ROAD_SNAP_DISTANCE &&\n      lineProj2 >= 0 && lineProj2 <= length2)\n\n        do (other) ->\n          point = pointOnLine\n          action.priority = 2\n          action.func = ->\n            segment.r.end = point\n            segment.q.severed = true\n\n            # if intersecting lines are too similar don't continue\n            if util.minDegreeDifference(other.dir(), segment.dir()) < config.mapGeneration.MINIMUM_INTERSECTION_DEVIATION\n              return false\n\n            other.split(point, segment, segments, qTree)\n\n            if (debugData?)\n              if (!debugData.intersectionsRadius?)\n                debugData.intersectionsRadius = []\n              debugData.intersectionsRadius.push(\n                x: point.x\n                y: point.y\n              )\n\n            return true\n\n  if (action.func)\n    return action.func()\n\n  return true\n\nglobalGoals = do ->\n  return {\n    generate: (previousSegment) ->\n      newBranches = []\n      if (!previousSegment.q.severed)\n\n        template = (direction, length, t, q) ->\n            segmentFactory.usingDirection(previousSegment.r.end, direction, length, t, q)\n\n        # used for highways or going straight on a normal branch\n        templateContinue = _.partialRight(template, previousSegment.length(), 0, previousSegment.q)\n        # not using q, i.e. not highways\n        templateBranch = _.partialRight(\n          template, config.mapGeneration.DEFAULT_SEGMENT_LENGTH, if previousSegment.q.highway then config.mapGeneration.NORMAL_BRANCH_TIME_DELAY_FROM_HIGHWAY else 0)\n\n        continueStraight = templateContinue(previousSegment.dir())\n        straightPop = heatmap.popOnRoad(continueStraight.r)\n\n        if (previousSegment.q.highway)\n          randomStraight = templateContinue(previousSegment.dir() + config.mapGeneration.RANDOM_STRAIGHT_ANGLE())\n\n          randomPop = heatmap.popOnRoad(randomStraight.r)\n          if (randomPop > straightPop)\n            newBranches.push(randomStraight)\n            roadPop = randomPop\n          else\n            newBranches.push(continueStraight)\n            roadPop = straightPop\n          if (roadPop > config.mapGeneration.HIGHWAY_BRANCH_POPULATION_THRESHOLD)\n\n            if (Math.random() < config.mapGeneration.HIGHWAY_BRANCH_PROBABILITY)\n              leftHighwayBranch = templateContinue(previousSegment.dir() - 90 + config.mapGeneration.RANDOM_BRANCH_ANGLE())\n              newBranches.push(leftHighwayBranch)\n            else if (Math.random() < config.mapGeneration.HIGHWAY_BRANCH_PROBABILITY)\n              rightHighwayBranch = templateContinue(previousSegment.dir() + 90 + config.mapGeneration.RANDOM_BRANCH_ANGLE())\n              newBranches.push(rightHighwayBranch)\n\n        else if (straightPop > config.mapGeneration.NORMAL_BRANCH_POPULATION_THRESHOLD)\n          newBranches.push(continueStraight)\n\n        if (straightPop > config.mapGeneration.NORMAL_BRANCH_POPULATION_THRESHOLD)\n          if (Math.random() < config.mapGeneration.DEFAULT_BRANCH_PROBABILITY)\n            leftBranch = templateBranch(previousSegment.dir() - 90 + config.mapGeneration.RANDOM_BRANCH_ANGLE())\n            newBranches.push(leftBranch)\n          else if (Math.random() < config.mapGeneration.DEFAULT_BRANCH_PROBABILITY)\n            rightBranch = templateBranch(previousSegment.dir() + 90 + config.mapGeneration.RANDOM_BRANCH_ANGLE())\n            newBranches.push(rightBranch)\n\n      for i in [0..newBranches.length-1] by 1\n        do (branch = newBranches[i]) ->\n          branch.setupBranchLinks = ->\n            # setup links between each current branch and each existing branch stemming from the previous segment\n            _.each(previousSegment.links.f, (link) ->\n              @links.b.push(link)\n              link.linksForEndContaining(previousSegment).push(this)\n            , @)\n\n            previousSegment.links.f.push(@)\n            @links.b.push(previousSegment)\n\n      return newBranches\n  }\n\naddSegment = (segment, segmentList, qTree) ->\n  segmentList.push(segment)\n  qTree.insert(segment.collider.limits())\n\ngenerate = (seed) ->\n  debugData = {}\n\n  Math.seedrandom(seed)\n  # this perlin noise library only supports 65536 different seeds\n  noise.seed(Math.random())\n\n  priorityQ = []\n  # setup first segments in queue\n  do ->\n    rootSegment = new Segment({x: 0, y: 0}, {x: config.mapGeneration.HIGHWAY_SEGMENT_LENGTH, y: 0}, 0, {highway: true})\n    oppositeDirection = segmentFactory.fromExisting(rootSegment)\n    newEnd =\n      x: rootSegment.r.start.x - config.mapGeneration.HIGHWAY_SEGMENT_LENGTH\n      y: oppositeDirection.r.end.y\n    oppositeDirection.r.setEnd(newEnd)\n    oppositeDirection.links.b.push(rootSegment)\n    rootSegment.links.b.push(oppositeDirection)\n    priorityQ.push(rootSegment)\n    priorityQ.push(oppositeDirection)\n\n  segments = []\n  qTree = new Quadtree(config.mapGeneration.QUADTREE_PARAMS,\n    config.mapGeneration.QUADTREE_MAX_OBJECTS, config.mapGeneration.QUADTREE_MAX_LEVELS)\n\n  while (priorityQ.length > 0 && segments.length < config.mapGeneration.SEGMENT_COUNT_LIMIT)\n    # pop smallest r(ti, ri, qi) from Q (i.e., smallest â€˜tâ€™)\n    minT = undefined\n    minT_i = 0\n    _.each(priorityQ, (segment, i) ->\n      if (!minT? || segment.t < minT)\n        minT = segment.t\n        minT_i = i\n    )\n\n    minSegment = priorityQ.splice(minT_i, 1)[0]\n\n    accepted = localConstraints(minSegment, segments, qTree, debugData)\n    if (accepted)\n      if (minSegment.setupBranchLinks?)\n        minSegment.setupBranchLinks()\n      addSegment(minSegment, segments, qTree)\n      _.each(globalGoals.generate(minSegment), (newSegment) ->\n        newSegment.t = minSegment.t + 1 + newSegment.t\n        priorityQ.push(newSegment)\n      )\n\n  id = 0\n  for segment in segments\n    segment.id = id++\n\n  console.log(\"#{segments.length} segments generated.\")\n\n  return {\n    segments: segments\n    qTree: qTree\n    heatmap: heatmap\n    debugData: debugData\n  }\n\n# register module\nroot = if typeof window isnt 'undefined' then window else if typeof self isnt 'undefined' then self else this\nroot.__CityGenModules__ ?= {}\nroot.__CityGenModules__['game_modules/mapgen'] = {\n  Segment: Segment\n  generate: generate\n}\n\n\n### BEGIN FILE: build.coffee\n\n\n# author: tmwhere.com\n\n_ = require('lodash')\n\nastar = require('generic_modules/astar')\ncollision = require('generic_modules/collision')\nmath = require('generic_modules/math')\nutil = require('generic_modules/utility')\n\nconfig = require('game_modules/config')\nmapgen = require('game_modules/mapgen')\n\nclass Building\n  @Type:\n    RESIDENTIAL: \"residential\"\n    IMPORT: \"import\"\n\n  @id: 0\n\n  constructor: (@center, @dir, @diagonal, @type, aspectRatio) ->\n    obj = @\n\n    aspectRatio = util.defaultFor(aspectRatio, 1)\n    # degrees to deviate either end to produce desired aspect ratio\n    @aspectDegree = math.atanDegrees(aspectRatio)\n    @corners = @generateCorners()\n\n    @collider = new collision.CollisionObject(this, collision.CollisionObject.Type.RECT, {corners: @corners})\n\n    @supply = []\n    @demand = []\n\n    @id = Building.id\n    Building.id += 1\n\n  generateCorners: ->\n    [\n      { x: @center.x + @diagonal * math.sinDegrees(+@aspectDegree + @dir), y: @center.y + @diagonal * math.cosDegrees(+@aspectDegree + @dir) }\n      { x: @center.x + @diagonal * math.sinDegrees(-@aspectDegree + @dir),  y: @center.y + @diagonal * math.cosDegrees(-@aspectDegree + @dir) }\n      { x: @center.x + @diagonal * math.sinDegrees(180 + @aspectDegree + @dir), y: @center.y + @diagonal * math.cosDegrees(180 + @aspectDegree + @dir) }\n      { x: @center.x + @diagonal * math.sinDegrees(180 - @aspectDegree + @dir), y: @center.y + @diagonal * math.cosDegrees(180 - @aspectDegree + @dir) }\n    ]\n\n  setCenter: (val) ->\n    @center = val\n    @corners = @generateCorners()\n    @collider.updateCollisionProperties({corners: @corners})\n\n  setDir: (val) ->\n    @dir = val\n    @corners = @generateCorners()\n    @collider.updateCollisionProperties({corners: @corners})\n\nbuildingsInRangeOf = (location, qTree) ->\n  {x, y} = location\n  matches = qTree.retrieve({\n    x: x - config.gameLogic.DEFAULT_PICKUP_RANGE\n    y: y - config.gameLogic.DEFAULT_PICKUP_RANGE\n    width: config.gameLogic.DEFAULT_PICKUP_RANGE * 2\n    height: config.gameLogic.DEFAULT_PICKUP_RANGE * 2\n  })\n\n  buildings = []\n  range = new collision.CollisionObject(undefined, collision.CollisionObject.Type.CIRCLE,\n    {center: {x: x, y: y}, radius: config.gameLogic.DEFAULT_PICKUP_RANGE})\n\n  _.each(matches, (match) ->\n    # if it's a building\n    if (match.o.supply? && match.o.demand? && range.collide(match.o.collider))\n      buildings.push(match.o)\n  )\n\n  return buildings\n\n# register module\nroot = if typeof window isnt 'undefined' then window else if typeof self isnt 'undefined' then self else this\nroot.__CityGenModules__ ?= {}\nroot.__CityGenModules__['game_modules/build'] =\n  buildingFactory: do ->\n    {\n      fromProbability: (time) ->\n        if Math.random() < 0.4\n          return @byType(Building.Type.IMPORT, time)\n        else\n          return @byType(Building.Type.RESIDENTIAL, time)\n\n      byType: (type, time) ->\n        building = undefined\n        switch type\n          when Building.Type.RESIDENTIAL\n            building = new Building({x: 0, y: 0}, 0, 80, Building.Type.RESIDENTIAL, math.randomRange(0.5, 2))\n          when Building.Type.IMPORT\n            building = new Building({x: 0, y: 0}, 0, 150, Building.Type.IMPORT, math.randomRange(0.5, 2))\n        return building\n\n      aroundSegment: (buildingTemplate, segment, count, radius, quadtree) ->\n        buildings = []\n        for i in [0...count] by 1\n          randomAngle = Math.random() * 360\n          randomRadius = Math.random() * radius\n          buildingCenter =\n            x: 0.5 * (segment.r.start.x + segment.r.end.x) + randomRadius * math.sinDegrees(randomAngle)\n            y: 0.5 * (segment.r.start.y + segment.r.end.y) + randomRadius * math.cosDegrees(randomAngle)\n          building = buildingTemplate()\n          building.setCenter(buildingCenter)\n          building.setDir(segment.dir())\n\n          permitBuilding = false\n          for i in [0...config.mapGeneration.BUILDING_PLACEMENT_LOOP_LIMIT] by 1\n            collisionCount = 0\n            # must query quadtree here, since building limits may have changed due to collision in previous iteration\n            potentialCollisions = quadtree.retrieve(building.collider.limits())\n            potentialCollisions = potentialCollisions.concat(buildings)\n            for obj in potentialCollisions\n              # if it is a quadtree result, unpack it\n              if (obj.o?)\n                obj = obj.o\n\n              result = building.collider.collide(obj.collider)\n              if (result)\n                collisionCount += 1\n                # no point continuing if on final loop\n                if (i == config.mapGeneration.BUILDING_PLACEMENT_LOOP_LIMIT - 1)\n                  break\n\n                # shift building to avoid colliding with existing object\n                building.setCenter(math.addPoints(building.center, result))\n\n            # no further checks necessary\n            if (collisionCount == 0)\n              permitBuilding = true\n              break\n\n          if (permitBuilding)\n            buildings.push(building)\n\n        return buildings\n    }\n";

// ---- compile & run ----
(function(global){
  function run(){
    if (!global.CoffeeScript || !global.CoffeeScript.compile) {
      console.error('CoffeeScript runtime not found. Paste the v1.12.7 minified runtime in the placeholder near the top of this file.');
      return;
    }
    try {
      var js = global.CoffeeScript.compile(COFFEE_SRC, {bare:true});
      (0, eval)(js);
      global.CityGenReady = true;
      console.log('CityGen compiled and executed (offline).');
    } catch (e) {
      console.error('Failed to compile/run CoffeeScript:', e);
    }
  }
  // Run synchronously. As a classic script, this will execute before the
  // deferred module script that depends on it, resolving the race condition.
  run();
})(typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : this));
})();
